
# 第十三章 拷贝控制

## 1. 拷贝控制操作
### 1.1 有哪些拷贝控制操作？
拷贝构造函数(copy constructor)
拷贝赋值运算符(copy assignment operator)
移动构造函数(move constructor)
移动赋值运算符(move assignment operator)
析构函数(destructor)
### 1.2 这些拷贝控制操作各自的作用分别是什么？
拷贝构造函数、移动构造函数定义了: 当用同类型的另一个对象 初始化本对象时 做什么。
拷贝赋值运算符、移动赋值运算符定义了: 将一个对象 赋予同类型的另一个对象时 做什么。
析构函数定义了:当此类型对象销毁时做什么。
### 1.3 为什么要自己定义 控制操作？
&emsp;&emsp; 如果我们不自己显示定义这些操作，那编译器会帮我们定义，但问题是编译器定义的版本的行为并不是我们想要的，依赖这些编译器定义的操作有可能会造成灾难。



&emsp;
## 2. 拷贝构造函数
### 2.1 什么样的函数是构造函数？
书上的定义：如果一个构造函数的第一个参数是自身类类型的引用，且任何额外的参数都有默认值，则此构造函数是 拷贝构造函数。
从上述定义可以总结出  拷贝构造函数 有如下几个特点：
> ① 首先要是构造函数；
> ② 第一个参数必须是自身类类型的引用（注意是引用哦）；
> ③ 如果有其它参数，则必须有默认值。

下面分别是什么构造函数？
```cpp
class Foo {
public:
    Foo();                          // 默认构造函数
    Foo(const Foo&);                // 拷贝构造破函数
    Foo(int size);                  // 普通的构造函数
    Foo(const Foo&, int size);      // 普通的构造函数
    ~Foo();                         // 析构函数
    // ...
};
```
### 2.2 拷贝构造函数 可以是 explicit的吗？
&emsp;&emsp; 拷贝构造函数检查会被 隐式地使用，因此拷贝构造函数通常不应该声明为explicit
### 2.3 拷贝构造函数 的首元素必须是const的吗？
&emsp;&emsp; 不是必须，虽然我们可以定义一个 非const引用 的拷贝构造函数，但是基于 `对于那些不会改变的变量，都尽量声明为const`的原则，因此还是声明为const比较好。
### 2.4 如果没有自己定义 拷贝构造函数，会发生什么？
&emsp;&emsp; 编译器会为我们生成 **合成拷贝构造函数**
### 2.5 合成默认构造函数 和 合成拷贝构造函数 的生成规则有何不同？
&emsp;&emsp; **合成默认构造函数** 只有在 类里没有任何构造函数时，编译器才会帮忙生成；而**合成拷贝构造函数**就不一样了，只要如果没有自己定义 拷贝构造函数，即使你定义了其它 构造函数，它也会帮你生成 合成拷贝构造函数。
我们来看下面的代码：
```cpp
class Foo_1 {
public:
    Foo(int size);                  // 普通的构造函数
};

class Foo_2 {
public:
    
};
```
在上面的代码中，编译器只会为类`Foo_1`生成 合成拷贝构造函数，但是会为 `Foo_2`生成 合成默认构造函数 和 合成拷贝构造函数 
### 拷贝初始化和直接初始化区别:
&emsp;&emsp; **直接初始化:** 实际上是要求编译器使用普通的函数匹配来选择与我们的参数最匹配的构造函数;
&emsp;&emsp; **拷贝初始化:** 实际上要求编译器将右侧的对象拷贝到正在创建的对象中,如果需要还要进行类型转换(调"构造函数"匹配建立左侧对象->调 "拷贝构造函数/移动拷贝构造函数" 将右侧对象拷贝);