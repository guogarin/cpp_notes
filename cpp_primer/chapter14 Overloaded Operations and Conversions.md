# 第十四章 重载运算符 与 类型转换

## 1. 基础知识
### 1.1 重载运算符的原理是？
&emsp;&emsp; 重载的运算符其实就是 具有特殊名字的函数：它们由 关键字`operator`和其后要定义的运算符号共同组成。
&emsp;&emsp; 和其它函数一样，重载的运算符也包含返回类型、参数列表以及函数体。

### 1.2 如何重载运算符？
&emsp;&emsp; 正如之前描述的，重载的运算符其实就是 具有特殊名字的函数，重载运算符函数由 关键字`operator`和其后要定义的运算符号共同组成，下面是一个重载`==`的例子：
```cpp
// 他有返回类型bool，也有参数列表、函数体
bool operator==(const Sales_data &lhs, const Sales_data &rhs)
{
    return lhs.isbn() == rhs.isbn() && lhs.units_sold == rhs.units_sold && lhs.revenue == rhs.revenue;
}
```

### 1.3 重载运算符函数 的参数数量
#### &emsp; 1.3.1 重载运算符函数 的参数数量 与什么有关？
&emsp;&emsp; 重载运算符函数 的参数数量 与该运算符作用的运算对象数量一样多：一元运算符有一个参数，二元运算符有两个。对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。
#### &emsp; 1.3.2 对于那些既可以当一元也可以当二元的运算符，怎么确定他是一元还是二元？
&emsp;&emsp; 有的运算符既可以当一元也可以当二元，这个时候要根据 重载运算符函数的参数数量 来判断语义。

### 1.4 重载运算符函数能否有默认实参？
&emsp;&emsp; 除了重载的函数调用运算符`operator()`之外，其他重载运算符不能含有默认实参。

### 1.5 为某个类重载运算符时，应该 重载运算符函数 定义为 成员函数 还是 普通的非成员函数 ？
&emsp;&emsp; 大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：

### 1.6 当 重载运算符函数 是 成员函数 时，为什么比 该函数 是 普通的非成员函数时 参数少一个？
&emsp;&emsp; 因为 成员函数有`this指针`，所以当 重载运算符函数 是 成员运算符函数（显式）的参数数量比运算符的运算对象总是少一个。

### 1.7 当 重载运算符函数 是 成员函数 时，`this指针`绑定的是？
&emsp;&emsp; 如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的`this指针`上，因此，成员运算符函数（显式）的参数数量比运算符的运算对象总是少一个。

### 1.8 重载运算符时，对参数类型有何要求？
&emsp;&emsp; 对于一个运算符函数来说，要么它是类的成员函数，要么它至少含有一个类类型参数，这就意味着无法对内置类型的运算对象进行运算符重载：
```cpp
// 错误: int是内置类型，我们不能重定义内置类型的运算符
int operator+(int, int);
```

### 1.9 我们可以重载哪些运算符？不能重载哪些运算符？
#### &emsp; 1.9.1 可重载运算符
|      |       |       |         |          |            |
| ---- | ----- | ----- | ------- | -------- | ---------- |
| `+ ` | `-	`  | `*	`  | `/	 `   | `%	 `    | `^`        |
| `& ` | `|	`  | `~	`  | `!	 `   | `,	 `    | `=`        |
| `< ` | `>	`  | `<= ` | `>= `   | `++	`    | `--`       |
| `<<` | `>> ` | `== ` | `!= `   | `&&	`    | `||	`      |
| `+=` | `-= ` | `/= ` | `%= `   | `^=	`    | `&=`       |
| `|=` | `*= ` | `<<=` | `>>= `  | `[]	`    | `()`       |
| `->` | `->*` | `new` | `new[]` | `delete` | `delete[]` |

#### &emsp; 1.9.2 不可重载运算符：
(1) 我们只能重载已存在的运算符，不能发明新的运算符号。
(2) 下面这几个也不能被重载：
|      |      |     |       |
| ---- | ---- | --- | ----- |
| `::` | `.*` | `.` | `? :` |

#### &emsp; 1.9.3 哪些运算符可以 但不应该 被重载的？为什么？
尽管有些运算符可以重载，但大多数情况下不建议重载：
&emsp;&emsp; 某些运算符指定了运算对象的求职顺序，因为使用重载的运算符本质上是一次函数的调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。特别是`,` 、`&` 、`||`、 `&&`，它们的运算对象的求值顺序无法被保留下来。
&emsp;&emsp; 因为它们的重载版本无法保留求值顺序 和/或 短路求值属性，因此不建议重载它们，因为当代码中使用了这些运算符的重载版本时，用户可能会忽然发现他们一直习惯的求值规则不再适用了。
**什么是短路求值？**
&emsp;&emsp; 作为"&&"和"||"操作符的操作数表达式，这些表达式在进行求值时，只要最终的结果已经可以确定是真或假，求值过程便告终止，这称之为短路求值（short-circuit evaluation）：
&emsp;假如expr1和expr2都是表达式，并且expr1的值为0，在下面这个逻辑表达式的求值过程中：
&emsp;&emsp; `expr1 && expr2`
expr2将不会进行求值，因为整个逻辑表达式的值已经可以确定为0。
&emsp;类似地，如果expr1的值不是0，那么在下面的这个逻辑表达式的求值过程中：
&emsp;&emsp; `expr1 || expr2`
expr2将不会进行求值，因为整个逻辑表达式的值已经确定为1。

### 1.10 运算符被重载后，它的 结合律、优先级 和什么有关？
&emsp;&emsp; 对于重载的运算符来说，其优先级和结合律 与对应的内置运算符保持一致，不考虑运算对象类型的话，`x == y + z;`永远等价于`x == (y + z)`.

### 1.11 怎么调用一个 重载的运算符？
有两种调用方法： 间接调用 和 函数调用
**非成员运算符函数：**
```cpp
// 两个等价调用
data1 + data2;           // 普通表达式
operator+(data1, data2); // 等价的函数调用
```
上面两个调用时等价的，它们都调用了 非成员函数`operator+`。
**成员运算符函数**
```cpp
data1 += data2;             // 基于“调用”的表达式
data1.operator+=(data2);    // 对成员运算符函数的等价调用
```
上面两个调用时等价的，它们都调用了成员函数`operator+=`，`this指针`绑定到左侧运算对象(data1)然后传入函数。

### 1.12 在重载运算符时，应该准守哪些准则？
(1) 虽然我们可以利用运算符重载 将运算符定义成任意规则，但最好让他们的含义与内置类型一致，不要违直觉定义:
> 如果类执行IO操作，那么<<和>>就应该与内置类型的IO一致。
> 如果类的某个操作是检查相等性，则定义`operator==`，通常也应该有`operator!=`。
> 如果类包含一个内在的单序比较操作，则定义`operator<`，如果有了`operator<`，一般也有其他关系操作。
> 重载运算符的返回类型通常应与内置版本的返回类型兼容：逻辑运算符和关系运算符应该返回bool，算术运算符应该返回类类型的值，赋值运算符和复合赋值运算符应该返回左侧运算对象的一个引用。
> 

### 1.13 如何确定 一个被重载的运算符应该是 成员函数 还是 非成员函数？
### 1.13.1 &emsp;一般准则
&emsp;&emsp; 定义重载运算符时，必须要先决定是声明为类成员函数还是普通的非成员函数。对此，有一些准则：
> 赋值(`=`、下标(`[]`、调用(`()`)和成员访问箭头运算符(`->`)**必须是**成员。
> 复合赋值运算符**一般来说**应该是成员，但并非必须，这一点和与之运算符略有不同。
> 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常**应该是**成员。
> 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，它们**应该是**普通的非成员函数。
> 输入输出运算符**必须是**非成员函数。
### 1.13.2 &emsp; 什么是 具有对称性的运算符？
&emsp;&emsp; 程序员希望能在含有 混合类型的表达式中 使用对称性运算符，例如，在求一个`int`和一个`double`的和时，它们任意一个都有可能是 左侧运算对象 或右侧运算对象，所以加法是对称的:
```cpp
1 + 2.2; // int为 左 侧运算符
2.2 + 1; // int为 右 侧运算符
```
### 1.13.3 &emsp; 为什么 具有对称性的运算符 应该声明为 非成员函数？
就拿 STL中的`string`类 的`+`运算符 来说吧，我们来看下面的代码：
```cpp
string s = "world";
string t = s + "!";     // 正确: we can add a const char* to a string
string u = "hi" + s;    // would be an error if + were a member of string
```
**如果把 `string`类 的`+`运算符 定义了 成员函数，`string u = "hi" + s;`就是错误的：**
&emsp;&emsp; `+`运算符 定义了 成员函数，而如果 一个运算符函数 是成员函数，则它的第一个（左侧）运算对象绑定到隐式的`this指针`上，即 `"hi"`将绑定到`this指针`，那 `string u = "hi" + s;`就相当于下面的代码：
```cpp
string u = ("hi".operator+(s)) // 错误，"hi"没有成员函数
```
但显然 `"hi"`是内置类型`const char*`，没有成员函数`operator+`，所以 `string u = "hi" + s;`会报错。
**如果把 `string`类 的`+`运算符 定义了 非成员函数**
如果 `+`运算符 定义了 非成员函数，那 `string u = "hi" + s;`就相当于下面的代码：
```cpp
string u = (operator+("hi", s)); // 正确，一个普通的函数调用，"hi"将被隐式转换为 string类型
```
显然上面是对的。
&emsp;&emsp; 因此 具有对称性的运算符 应该声明为 非成员函数






&emsp;
&emsp;
## 2. 输入 和 输出 运算符
### 2.1 为什么要 重载 输入 和 输出 运算符？
&emsp;&emsp; IO标准库 分别使用 `>>`、`<<`执行输入 和 输出 操作，对于这两个运算符来说，IO库只定义了其读写内置类型的版本，而在自定义的类中，需要类的设计者自定义适合该类的新版本以支持IO操作。

### 2.2 重载 输出运算符 `<<`
&emsp;&emsp; 




### 2
&emsp;&emsp; 


### 2
&emsp;&emsp; 


### 2
&emsp;&emsp; 


### 2
&emsp;&emsp; 


### 2
&emsp;&emsp; 


### 2
&emsp;&emsp; 










https://r00tk1ts.github.io/2018/11/29/C++%20Primer%20-%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/

