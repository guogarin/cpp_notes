# 第十四章 重载运算符 与 类型转换

## 1. 基础知识
### 1.1 重载运算符的原理是？
&emsp;&emsp; 重载的运算符其实就是 具有特殊名字的函数：它们由 关键字`operator`和其后要定义的运算符号共同组成。
&emsp;&emsp; 和其它函数一样，重载的运算符也包含返回类型、参数列表以及函数体。

### 1.2 如何重载运算符？
&emsp;&emsp; 正如之前描述的，重载的运算符其实就是 具有特殊名字的函数，重载运算符函数由 关键字`operator`和其后要定义的运算符号共同组成，下面是一个重载`==`的例子：
```cpp
// 他有返回类型bool，也有参数列表、函数体
bool operator==(const Sales_data &lhs, const Sales_data &rhs)
{
    return lhs.isbn() == rhs.isbn() && lhs.units_sold == rhs.units_sold && lhs.revenue == rhs.revenue;
}
```

### 1.3 重载运算符函数 的参数数量
#### &emsp; 1.3.1 重载运算符函数 的参数数量 与什么有关？
&emsp;&emsp; 重载运算符函数 的参数数量 与该运算符作用的运算对象数量一样多：一元运算符有一个参数，二元运算符有两个。对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。
#### &emsp; 1.3.2 对于那些既可以当一元也可以当二元的运算符，怎么确定他是一元还是二元？
&emsp;&emsp; 有的运算符既可以当一元也可以当二元，这个时候要根据 重载运算符函数的参数数量 来判断语义。

### 1.4 重载运算符函数能否有默认实参？
&emsp;&emsp; 除了重载的函数调用运算符`operator()`之外，其他重载运算符不能含有默认实参。

### 1.5 为某个类重载运算符时，应该 重载运算符函数 定义为 成员函数 还是 普通的非成员函数 ？
&emsp;&emsp; 大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：

### 1.6 当 重载运算符函数 是 成员函数 时，为什么比 该函数 是 普通的非成员函数时 参数少一个？
&emsp;&emsp; 因为 成员函数有`this指针`，所以当 重载运算符函数 是 成员运算符函数（显式）的参数数量比运算符的运算对象总是少一个。

### 1.7 当 重载运算符函数 是 成员函数 时，`this指针`绑定的是？
&emsp;&emsp; 如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的`this指针`上，因此，成员运算符函数（显式）的参数数量比运算符的运算对象总是少一个。

### 1.8 重载运算符时，对参数类型有何要求？
&emsp;&emsp; 对于一个运算符函数来说，要么它是类的成员函数，要么它至少含有一个类类型参数，这就意味着无法对内置类型的运算对象进行运算符重载：
```cpp
// 错误: int是内置类型，我们不能重定义内置类型的运算符
int operator+(int, int);
```

### 1.9 我们可以重载哪些运算符？不能重载哪些运算符？
#### &emsp; 1.9.1 可重载运算符
|      |       |       |         |          |            |
| ---- | ----- | ----- | ------- | -------- | ---------- |
| `+ ` | `-	`  | `*	`  | `/	 `   | `%	 `    | `^`        |
| `& ` | `|	`  | `~	`  | `!	 `   | `,	 `    | `=`        |
| `< ` | `>	`  | `<= ` | `>= `   | `++	`    | `--`       |
| `<<` | `>> ` | `== ` | `!= `   | `&&	`    | `||	`      |
| `+=` | `-= ` | `/= ` | `%= `   | `^=	`    | `&=`       |
| `|=` | `*= ` | `<<=` | `>>= `  | `[]	`    | `()`       |
| `->` | `->*` | `new` | `new[]` | `delete` | `delete[]` |

#### &emsp; 1.9.2 不可重载运算符：
(1) 我们只能重载已存在的运算符，不能发明新的运算符号。
(2) 下面这几个也不能被重载：
|      |      |     |       |
| ---- | ---- | --- | ----- |
| `::` | `.*` | `.` | `? :` |

#### &emsp; 1.9.3 哪些运算符可以 但不应该 被重载的？为什么？
尽管有些运算符可以重载，但大多数情况下不建议重载：
&emsp;&emsp; 某些运算符指定了运算对象的求职顺序，因为使用重载的运算符本质上是一次函数的调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。特别是`,` 、`&` 、`||`、 `&&`，它们的运算对象的求值顺序无法被保留下来。
&emsp;&emsp; 因为它们的重载版本无法保留求值顺序 和/或 短路求值属性，因此不建议重载它们，因为当代码中使用了这些运算符的重载版本时，用户可能会忽然发现他们一直习惯的求值规则不再适用了。
**什么是短路求值？**
&emsp;&emsp; 作为"&&"和"||"操作符的操作数表达式，这些表达式在进行求值时，只要最终的结果已经可以确定是真或假，求值过程便告终止，这称之为短路求值（short-circuit evaluation）：
&emsp;假如expr1和expr2都是表达式，并且expr1的值为0，在下面这个逻辑表达式的求值过程中：
&emsp;&emsp; `expr1 && expr2`
expr2将不会进行求值，因为整个逻辑表达式的值已经可以确定为0。
&emsp;类似地，如果expr1的值不是0，那么在下面的这个逻辑表达式的求值过程中：
&emsp;&emsp; `expr1 || expr2`
expr2将不会进行求值，因为整个逻辑表达式的值已经确定为1。

### 1.10 运算符被重载后，它的 结合律、优先级 和什么有关？
&emsp;&emsp; 对于重载的运算符来说，其优先级和结合律 与对应的内置运算符保持一致，不考虑运算对象类型的话，`x == y + z;`永远等价于`x == (y + z)`.

### 1.11 怎么调用一个 重载的运算符？
有两种调用方法： 间接调用 和 函数调用
**非成员运算符函数：**
```cpp
// 两个等价调用
data1 + data2;           // 普通表达式
operator+(data1, data2); // 等价的函数调用
```
上面两个调用时等价的，它们都调用了 非成员函数`operator+`。
**成员运算符函数**
```cpp
data1 += data2;             // 基于“调用”的表达式
data1.operator+=(data2);    // 对成员运算符函数的等价调用
```
上面两个调用时等价的，它们都调用了成员函数`operator+=`，`this指针`绑定到左侧运算对象(data1)然后传入函数。

### 1.12 在重载运算符时，应该准守哪些准则？
(1) 虽然我们可以利用运算符重载 将运算符定义成任意规则，但最好让他们的含义与内置类型一致，不要违直觉定义:
> 如果类执行IO操作，那么<<和>>就应该与内置类型的IO一致。
> 如果类的某个操作是检查相等性，则定义`operator==`，通常也应该有`operator!=`。
> 如果类包含一个内在的单序比较操作，则定义`operator<`，如果有了`operator<`，一般也有其他关系操作。
> 重载运算符的返回类型通常应与内置版本的返回类型兼容：逻辑运算符和关系运算符应该返回bool，算术运算符应该返回类类型的值，赋值运算符和复合赋值运算符应该返回左侧运算对象的一个引用。
> 

### 1.13 如何确定 一个被重载的运算符应该是 成员函数 还是 非成员函数？
### 1.13.1 &emsp;一般准则
&emsp;&emsp; 定义重载运算符时，必须要先决定是声明为类成员函数还是普通的非成员函数。对此，有一些准则：
> 赋值(`=`、下标(`[]`、调用(`()`)和成员访问箭头运算符(`->`)**必须是**成员。
> 复合赋值运算符**一般来说**应该是成员，但并非必须，这一点和与之运算符略有不同。
> 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常**应该是**成员。
> 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，它们**应该是**普通的非成员函数。
> 输入输出运算符**必须是**非成员函数。
### 1.13.2 &emsp; 什么是 具有对称性的运算符？
&emsp;&emsp; 程序员希望能在含有 混合类型的表达式中 使用对称性运算符，例如，在求一个`int`和一个`double`的和时，它们任意一个都有可能是 左侧运算对象 或右侧运算对象，所以加法是对称的:
```cpp
1 + 2.2; // int为 左 侧运算符
2.2 + 1; // int为 右 侧运算符
```
### 1.13.3 &emsp; 为什么 具有对称性的运算符 应该声明为 非成员函数？
就拿 STL中的`string`类 的`+`运算符 来说吧，我们来看下面的代码：
```cpp
string s = "world";
string t = s + "!";     // 正确: we can add a const char* to a string
string u = "hi" + s;    // would be an error if + were a member of string
```
**如果把 `string`类 的`+`运算符 定义了 成员函数，`string u = "hi" + s;`就是错误的：**
&emsp;&emsp; `+`运算符 定义了 成员函数，而如果 一个运算符函数 是成员函数，则它的第一个（左侧）运算对象绑定到隐式的`this指针`上，即 `"hi"`将绑定到`this指针`，那 `string u = "hi" + s;`就相当于下面的代码：
```cpp
string u = ("hi".operator+(s)) // 错误，"hi"没有成员函数
```
但显然 `"hi"`是内置类型`const char*`，没有成员函数`operator+`，所以 `string u = "hi" + s;`会报错。
**如果把 `string`类 的`+`运算符 定义了 非成员函数**
如果 `+`运算符 定义了 非成员函数，那 `string u = "hi" + s;`就相当于下面的代码：
```cpp
string u = (operator+("hi", s)); // 正确，一个普通的函数调用，"hi"将被隐式转换为 string类型
```
显然上面是对的。
&emsp;&emsp; 因此 具有对称性的运算符 应该声明为 非成员函数






&emsp;
&emsp;
## 2. 为什么要 重载 输入 和 输出 运算符？
&emsp;&emsp; IO标准库 分别使用 `>>`、`<<`执行输入 和 输出 操作，对于这两个运算符来说，IO库只定义了其读写内置类型的版本，而在自定义的类中，需要类的设计者自定义适合该类的新版本以支持IO操作。






&emsp;
&emsp;
## 3. 重载 输出运算符 `<<`
### 3.1 输出运算符 `<<` 的形参、返回值 一般是什么样的？为什么？
#### &emsp; 3.1.1 形参
&emsp; 通常情况下：
&emsp;&emsp; **第一个形参** 是一个 非常量`ostream对象`的引用。非常量是因为向流写入内容会改变其状态，而引用则是因为ostream不能拷贝。
&emsp;&emsp; **第二个形参** 一般是一个 常量的引用，该常量是我们想要打印的类类型。这里的引用是因为我们希望避免复制实参，常量则是因为打印对象通常不会改变对象内容。
#### &emsp; 3.1.2 返回值 
&emsp;&emsp; `operator<<`一般返回它的ostream形参，为了与其他类新的的`<<`一致，`operator<<`一般返回它的ostream形参的引用。

### 3.2 为`Sales_data`类重载 输出运算符 `<<`
&emsp;&emsp; 
```cpp
ostream& operator<<(ostream &os, const Sales_data &item)
{
    os << item.isbn() << " " << item.units_sold << " "
        << item.revenue << " " << item.avg_price();
    return os;
}
```

### 3.3 重载 输出运算符 `<<`时 是否应该在 重载运算符函数里 提供换行符等格式化操作？
&emsp;&emsp; 不应该，输出运算符 应该主要负责打印对象的内容而非控制格式，因此输出运算符不应该打印换行符。

### 3.4 输出运算符应该是 成员函数 还是 非成员函数？
&emsp;&emsp; **必须是 非成员函数**。因为作为成员函数，左操作数必须是该类类型的对象，那就需要这样调用 输出运算符了：
```cpp
Sales_data data;
data << cout; // 因为 输出运算符 被定义为 Sales_data类的成员函数，因此只能这样调用
```
这样显然和标准库的写法不一致，因此我们若希望为类自定义IO操作，则必须将其定义为 非成员函数。

### 3.5 重载 输出运算符 `<<`时，应该怎么声明 该重载运算符函数？
&emsp;&emsp; 必须是 非成员函数，而且要声明为 该类的友元，因为IO运算符往往需要读写 类的非公有数据成员，所以IO运算符一般被声明为友元。






&emsp;
&emsp;
## 4. 重载 输入运算符 `>>`
### 4.1 重载 输入运算符 `>>`时，形参、返回值 一般是什么样的？为什么？
&emsp; 通常情况下：
&emsp;&emsp; **第一个形参** 是一个 非常量`istream对象`的引用。非常量是因为向流读取内容会改变其状态，而引用则是因为ostream不能拷贝。
&emsp;&emsp; **第二个形参** 一般是一个 该类类型的引用。这里的引用是因为我们需要改变实参。
#### &emsp; 3.1.2 返回值 
&emsp;&emsp; `operator>>`一般返回它的istream形参，为了与其他类新的的`>>`一致，`operator>>`一般返回它的istream形参的引用。

### 4.2 重载 输入运算符 `>>` 和 输出运算符 `<<` 时有啥区别？
(1) 形参的区别
(2) 重载 输入运算符 `>>`时需要多做一个步骤：要额外考虑失败的情况。

### 4.3 重载 输入运算符 `>>`时会遇到哪些错误？
(1) 流含有错误类型的数据读取操作时。例如`cin`期望读取的是`int`类型，但读取到的却是字符串，此时就会发生错误。
(2) 当读取操作到达文件末尾，或是遇到输入流的其他错误时也会失败。

### 4.4 输入运算符应该是 成员函数 还是 非成员函数？
&emsp;&emsp; 非成员函数，然后声明为该类的友元，原因和 输出运算符 一样。

### 4.5 为`Sales_data`类重载 输入运算符
```cpp
istream& operator>>(istream &is, Sales_data& item)
{
    double price;
    is >> item.booNo >> item.units_sold >> price;
    if(is)  //如果读取成功
        item.revenue = item.units_sold * price;
    else    // 如果读取失败
        item = Sales_data(); // 若读取失败，则将item置空
    return is;
}
```
在上面的输入`is >> item.booNo >> item.units_sold >> price;`中，我们没有区分具体是哪一个变量在读取的时候发生了错误，因为具体是哪个发生错误并不重要，只要有错误发生，我们都要将`item`置空。

### 4.6 假如在读取的时候发生错误了，重载的输入运算符应该怎么做？
&emsp;&emsp; **当读取操作发生错误时，输入运算符应该负责从错误中恢复。**
&emsp;&emsp; 就拿前面重载的 `Sales_data`类的 输入运算符来说吧，在语句`is >> item.booNo >> item.units_sold >> price;`中，错误可能发生在读取`item.booNo`时，或是读取 `item.units_sold` ，也可能是读取`price`的时候，如果错误发生在读取`item.units_sold`，这意味着`item.booNo`读取成功了，但是`item.units_sold` 、`price`、`item.revenue`都没有读取成功，这可能导致 它们和 完全不匹配的`booNo`组合在一起，这会给用户带来很大的困扰。
&emsp;&emsp; 因此 输入运算符应该负责从错误中恢复，在上面的 `Sales_data`类的 输入运算符中，是通过将一个默认初始化的Sales_data赋给`item`来完成的。






&emsp;
&emsp;
## 5. 重载 算术运算符 
### 5.1 对于 算术运算符 和 关系运算符，应该将其定义为 成员函数 还是 非成员函数？ 为什么？
&emsp;&emsp; 通常情况下，我们应该将 算术运算符 和 关系运算符 定义为 非成员函数，这样左侧、右侧的运算对象就能互相转换了，要不然左侧就必须是该对象，具体的分析见前面`string`类的`+`运算符的例子。

### 5.2 重载算符运算符的时候有没有什么可以“偷懒”的办法？
&emsp;&emsp; 偷懒是不能偷懒的，但一般一个类定义了算术运算符，那么他一般也会定义一个对应的复核赋值运算符（比如`-`对应`-=`、`+`对应`+=`），此时利用 对应的复核赋值运算符 来实现 该算术运算符是最方便的。

### 5.3 为`Sales_data`类定义 `+`运算符
#### &emsp;(1) 形参和返回值
**形参**
&emsp;&emsp; `+`运算符 肯定是接收两个 `Sales_data`对象，而且相加是不会改变实参的值的，因此用 const比较合适。
**返回值**
#### &emsp;(2) 定义
&emsp;&emsp; 算术运算符 一般是计算得到一个新值，这个值一般是一个局部变量，运算完成后一般返回这个局部变量的副本。
&emsp;&emsp; 一般来说，如果一个类定义了算术运算符，那么他一般也会定义一个对应的复合赋值运算符，在这种情况下，最有效的方法是使用复核赋值来定义算术运算符。
```cpp
Sales_data operator+(const Sales_data &lhs, const Sales_data &rhs)
{
    Sales_data sum = lhs;   // 将lhs拷贝给临时变量sum
    sum += rhs;         // 利用 += 运算符来完成工作，节省代码量（这个在后面会定义）
    return sum;
}
```






&emsp;
&emsp;
## 6. 重载 关系运算符
### 6.1 对于 关系运算符，应该将其定义为 成员函数 还是 非成员函数？ 为什么？
&emsp;&emsp; 和算术运算符一样，我们通常应该将 关系运算符 定义为 非成员函数，这样左侧、右侧的运算对象就能互相转换了，要不然左侧就必须是该对象，具体的分析见前面`string`类的`+`运算符的例子。





https://r00tk1ts.github.io/2018/11/29/C++%20Primer%20-%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/

