# 第十四章 重载运算符 与 类型转换

## 1. 基础知识
### 1.1 重载运算符的原理是？
&emsp;&emsp; 重载的运算符其实就是 具有特殊名字的函数：它们由 关键字`operator`和其后要定义的运算符号共同组成。
&emsp;&emsp; 和其它函数一样，重载的运算符也包含返回类型、参数列表以及函数体。

### 1.2 如何重载运算符？
&emsp;&emsp; 正如之前描述的，重载的运算符其实就是 具有特殊名字的函数，重载运算符函数由 关键字`operator`和其后要定义的运算符号共同组成，下面是一个重载`==`的例子：
```cpp
// 他有返回类型bool，也有参数列表、函数体
bool operator==(const Sales_data &lhs, const Sales_data &rhs)
{
    return lhs.isbn() == rhs.isbn() && lhs.units_sold == rhs.units_sold && lhs.revenue == rhs.revenue;
}
```

### 1.3 重载运算符函数 的参数数量
#### &emsp; 1.3.1 重载运算符函数 的参数数量 与什么有关？
&emsp;&emsp; 重载运算符函数 的参数数量 与该运算符作用的运算对象数量一样多：一元运算符有一个参数，二元运算符有两个。对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。
#### &emsp; 1.3.2 对于那些既可以当一元也可以当二元的运算符，怎么确定他是一元还是二元？
&emsp;&emsp; 有的运算符既可以当一元也可以当二元，这个时候要根据 重载运算符函数的参数数量 来判断语义。

### 1.4 重载运算符函数能否有默认实参？
&emsp;&emsp; 除了重载的函数调用运算符`operator()`之外，其他重载运算符不能含有默认实参。

### 1.5 为某个类重载运算符时，应该 重载运算符函数 定义为 成员函数 还是 普通的非成员函数 ？
&emsp;&emsp; 大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示：

### 1.6 当 重载运算符函数 是 成员函数 时，为什么比 该函数 是 普通的非成员函数时 参数少一个？
&emsp;&emsp; 因为 成员函数有`this指针`，所以当 重载运算符函数 是 成员运算符函数（显式）的参数数量比运算符的运算对象总是少一个。

### 1.7 当 重载运算符函数 是 成员函数 时，`this指针`绑定的是？
&emsp;&emsp; 如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的`this指针`上，因此，成员运算符函数（显式）的参数数量比运算符的运算对象总是少一个。

### 1.8 重载运算符时，对参数类型有何要求？
&emsp;&emsp; 对于一个运算符函数来说，要么它是类的成员函数，要么它至少含有一个类类型参数，这就意味着无法对内置类型的运算对象进行运算符重载：
```cpp
// 错误: int是内置类型，我们不能重定义内置类型的运算符
int operator+(int, int);
```

### 1.9 我们可以重载哪些运算符？不能重载哪些运算符？
#### &emsp; 1.9.1 可重载运算符
|      |       |       |         |          |            |
| ---- | ----- | ----- | ------- | -------- | ---------- |
| `+ ` | `-	`  | `*	`  | `/	 `   | `%	 `    | `^`        |
| `& ` | `|	`  | `~	`  | `!	 `   | `,	 `    | `=`        |
| `< ` | `>	`  | `<= ` | `>= `   | `++	`    | `--`       |
| `<<` | `>> ` | `== ` | `!= `   | `&&	`    | `||	`      |
| `+=` | `-= ` | `/= ` | `%= `   | `^=	`    | `&=`       |
| `|=` | `*= ` | `<<=` | `>>= `  | `[]	`    | `()`       |
| `->` | `->*` | `new` | `new[]` | `delete` | `delete[]` |

#### &emsp; 1.9.2 不可重载运算符：
(1) 我们只能重载已存在的运算符，不能发明新的运算符号。
(2) 下面这几个也不能被重载：
|      |      |     |       |
| ---- | ---- | --- | ----- |
| `::` | `.*` | `.` | `? :` |

#### &emsp; 1.9.3 哪些运算符可以 但不应该 被重载的？为什么？
尽管有些运算符可以重载，但大多数情况下不建议重载：
&emsp;&emsp; 某些运算符指定了运算对象的求职顺序，因为使用重载的运算符本质上是一次函数的调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。特别是`,` 、`&` 、`||`、 `&&`，它们的运算对象的求值顺序无法被保留下来。
&emsp;&emsp; 因为它们的重载版本无法保留求值顺序 和/或 短路求值属性，因此不建议重载它们，因为当代码中使用了这些运算符的重载版本时，用户可能会忽然发现他们一直习惯的求值规则不再适用了。
**什么是短路求值？**
&emsp;&emsp; 作为"&&"和"||"操作符的操作数表达式，这些表达式在进行求值时，只要最终的结果已经可以确定是真或假，求值过程便告终止，这称之为短路求值（short-circuit evaluation）：
&emsp;假如expr1和expr2都是表达式，并且expr1的值为0，在下面这个逻辑表达式的求值过程中：
&emsp;&emsp; `expr1 && expr2`
expr2将不会进行求值，因为整个逻辑表达式的值已经可以确定为0。
&emsp;类似地，如果expr1的值不是0，那么在下面的这个逻辑表达式的求值过程中：
&emsp;&emsp; `expr1 || expr2`
expr2将不会进行求值，因为整个逻辑表达式的值已经确定为1。

### 1.10 运算符被重载后，它的 结合律、优先级 和什么有关？
&emsp;&emsp; 对于重载的运算符来说，其优先级和结合律 与对应的内置运算符保持一致，不考虑运算对象类型的话，`x == y + z;`永远等价于`x == (y + z)`.

### 1.11 怎么调用一个 重载的运算符？
有两种调用方法： 间接调用 和 函数调用
**非成员运算符函数：**
```cpp
// 两个等价调用
data1 + data2;           // 普通表达式
operator+(data1, data2); // 等价的函数调用
```
上面两个调用时等价的，它们都调用了 非成员函数`operator+`。
**成员运算符函数**
```cpp
data1 += data2;             // 基于“调用”的表达式
data1.operator+=(data2);    // 对成员运算符函数的等价调用
```
上面两个调用时等价的，它们都调用了成员函数`operator+=`，`this指针`绑定到左侧运算对象(data1)然后传入函数。

### 1.12 在重载运算符时，应该准守哪些准则？
(1) 虽然我们可以利用运算符重载 将运算符定义成任意规则，但最好让他们的含义与内置类型一致，不要违直觉定义:
> 如果类执行IO操作，那么<<和>>就应该与内置类型的IO一致。
> 如果类的某个操作是检查相等性，则定义`operator==`，通常也应该有`operator!=`。
> 如果类包含一个内在的单序比较操作，则定义`operator<`，如果有了`operator<`，一般也有其他关系操作。
> 重载运算符的返回类型通常应与内置版本的返回类型兼容：逻辑运算符和关系运算符应该返回bool，算术运算符应该返回类类型的值，赋值运算符和复合赋值运算符应该返回左侧运算对象的一个引用。
> 

### 1.13 如何确定 一个被重载的运算符应该是 成员函数 还是 非成员函数？
### 1.13.1 &emsp;一般准则
&emsp;&emsp; 定义重载运算符时，必须要先决定是声明为类成员函数还是普通的非成员函数。对此，有一些准则：
> 赋值(`=`、下标(`[]`、调用(`()`)和成员访问箭头运算符(`->`)**必须是**成员。
> 复合赋值运算符**一般来说**应该是成员，但并非必须，这一点和与之运算符略有不同。
> 改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常**应该是**成员。
> 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，它们**应该是**普通的非成员函数。
> 输入输出运算符**必须是**非成员函数。
### 1.13.2 &emsp; 什么是 具有对称性的运算符？
&emsp;&emsp; 程序员希望能在含有 混合类型的表达式中 使用对称性运算符，例如，在求一个`int`和一个`double`的和时，它们任意一个都有可能是 左侧运算对象 或右侧运算对象，所以加法是对称的:
```cpp
1 + 2.2; // int为 左 侧运算符
2.2 + 1; // int为 右 侧运算符
```
### 1.13.3 &emsp; 为什么 具有对称性的运算符 应该声明为 非成员函数？
就拿 STL中的`string`类 的`+`运算符 来说吧，我们来看下面的代码：
```cpp
string s = "world";
string t = s + "!";     // 正确: we can add a const char* to a string
string u = "hi" + s;    // would be an error if + were a member of string
```
**如果把 `string`类 的`+`运算符 定义了 成员函数，`string u = "hi" + s;`就是错误的：**
&emsp;&emsp; `+`运算符 定义了 成员函数，而如果 一个运算符函数 是成员函数，则它的第一个（左侧）运算对象绑定到隐式的`this指针`上，即 `"hi"`将绑定到`this指针`，那 `string u = "hi" + s;`就相当于下面的代码：
```cpp
string u = ("hi".operator+(s)) // 错误，"hi"没有成员函数
```
但显然 `"hi"`是内置类型`const char*`，没有成员函数`operator+`，所以 `string u = "hi" + s;`会报错。
**如果把 `string`类 的`+`运算符 定义了 非成员函数**
如果 `+`运算符 定义了 非成员函数，那 `string u = "hi" + s;`就相当于下面的代码：
```cpp
string u = (operator+("hi", s)); // 正确，一个普通的函数调用，"hi"将被隐式转换为 string类型
```
显然上面是对的。
&emsp;&emsp; 因此 具有对称性的运算符 应该声明为 非成员函数






&emsp;
&emsp;
## 2. 为什么要 重载 输入 和 输出 运算符？
&emsp;&emsp; IO标准库 分别使用 `>>`、`<<`执行输入 和 输出 操作，对于这两个运算符来说，IO库只定义了其读写内置类型的版本，而在自定义的类中，需要类的设计者自定义适合该类的新版本以支持IO操作。






&emsp;
&emsp;
## 3. 重载 输出运算符 `<<`
### 3.1 输出运算符 `<<` 的形参、返回值 一般是什么样的？为什么？
#### &emsp; 3.1.1 形参
&emsp; 通常情况下：
&emsp;&emsp; **第一个形参** 是一个 非常量`ostream对象`的引用。非常量是因为向流写入内容会改变其状态，而引用则是因为ostream不能拷贝。
&emsp;&emsp; **第二个形参** 一般是一个 常量的引用，该常量是我们想要打印的类类型。这里的引用是因为我们希望避免复制实参，常量则是因为打印对象通常不会改变对象内容。
#### &emsp; 3.1.2 返回值 
&emsp;&emsp; `operator<<`一般返回它的ostream形参，为了与其他类新的的`<<`一致，`operator<<`一般返回它的ostream形参的引用。

### 3.2 为`Sales_data`类重载 输出运算符 `<<`
&emsp;&emsp; 
```cpp
ostream& operator<<(ostream &os, const Sales_data &item)
{
    os << item.isbn() << " " << item.units_sold << " "
        << item.revenue << " " << item.avg_price();
    return os;
}
```

### 3.3 重载 输出运算符 `<<`时 是否应该在 重载运算符函数里 提供换行符等格式化操作？
&emsp;&emsp; 不应该，输出运算符 应该主要负责打印对象的内容而非控制格式，因此输出运算符不应该打印换行符。

### 3.4 输出运算符应该是 成员函数 还是 非成员函数？
&emsp;&emsp; **必须是 非成员函数**。因为作为成员函数，左操作数必须是该类类型的对象，那就需要这样调用 输出运算符了：
```cpp
Sales_data data;
data << cout; // 因为 输出运算符 被定义为 Sales_data类的成员函数，因此只能这样调用
```
这样显然和标准库的写法不一致，因此我们若希望为类自定义IO操作，则必须将其定义为 非成员函数。

### 3.5 重载 输出运算符 `<<`时，应该怎么声明 该重载运算符函数？
&emsp;&emsp; 必须是 非成员函数，而且要声明为 该类的友元，因为IO运算符往往需要读写 类的非公有数据成员，所以IO运算符一般被声明为友元。






&emsp;
&emsp;
## 4. 重载 输入运算符 `>>`
### 4.1 重载 输入运算符 `>>`时，形参、返回值 一般是什么样的？为什么？
&emsp; 通常情况下：
&emsp;&emsp; **第一个形参** 是一个 非常量`istream对象`的引用。非常量是因为向流读取内容会改变其状态，而引用则是因为ostream不能拷贝。
&emsp;&emsp; **第二个形参** 一般是一个 该类类型的引用。这里的引用是因为我们需要改变实参。
#### &emsp; 3.1.2 返回值 
&emsp;&emsp; `operator>>`一般返回它的istream形参，为了与其他类新的的`>>`一致，`operator>>`一般返回它的istream形参的引用。

### 4.2 重载 输入运算符 `>>` 和 输出运算符 `<<` 时有啥区别？
(1) 形参的区别
(2) 重载 输入运算符 `>>`时需要多做一个步骤：要额外考虑失败的情况。

### 4.3 重载 输入运算符 `>>`时会遇到哪些错误？
(1) 流含有错误类型的数据读取操作时。例如`cin`期望读取的是`int`类型，但读取到的却是字符串，此时就会发生错误。
(2) 当读取操作到达文件末尾，或是遇到输入流的其他错误时也会失败。

### 4.4 输入运算符应该是 成员函数 还是 非成员函数？
&emsp;&emsp; 非成员函数，然后声明为该类的友元，原因和 输出运算符 一样。

### 4.5 为`Sales_data`类重载 输入运算符
```cpp
istream& operator>>(istream &is, Sales_data& item)
{
    double price;
    is >> item.booNo >> item.units_sold >> price;
    if(is)  //如果读取成功
        item.revenue = item.units_sold * price;
    else    // 如果读取失败
        item = Sales_data(); // 若读取失败，则将item置空
    return is;
}
```
在上面的输入`is >> item.booNo >> item.units_sold >> price;`中，我们没有区分具体是哪一个变量在读取的时候发生了错误，因为具体是哪个发生错误并不重要，只要有错误发生，我们都要将`item`置空。

### 4.6 假如在读取的时候发生错误了，重载的输入运算符应该怎么做？
&emsp;&emsp; **当读取操作发生错误时，输入运算符应该负责从错误中恢复。**
&emsp;&emsp; 就拿前面重载的 `Sales_data`类的 输入运算符来说吧，在语句`is >> item.booNo >> item.units_sold >> price;`中，错误可能发生在读取`item.booNo`时，或是读取 `item.units_sold` ，也可能是读取`price`的时候，如果错误发生在读取`item.units_sold`，这意味着`item.booNo`读取成功了，但是`item.units_sold` 、`price`、`item.revenue`都没有读取成功，这可能导致 它们和 完全不匹配的`booNo`组合在一起，这会给用户带来很大的困扰。
&emsp;&emsp; 因此 输入运算符应该负责从错误中恢复，在上面的 `Sales_data`类的 输入运算符中，是通过将一个默认初始化的Sales_data赋给`item`来完成的。






&emsp;
&emsp;
## 5. 重载 算术运算符 
### 5.1 对于 算术运算符 和 关系运算符，应该将其定义为 成员函数 还是 非成员函数？ 为什么？
&emsp;&emsp; 通常情况下，我们应该将 算术运算符 和 关系运算符 定义为 非成员函数，这样左侧、右侧的运算对象就能互相转换了，要不然左侧就必须是该对象，具体的分析见前面`string`类的`+`运算符的例子。

### 5.2 重载算符运算符的时候有没有什么可以“偷懒”的办法？
&emsp;&emsp; 偷懒是不能偷懒的，但一般一个类定义了算术运算符，那么他一般也会定义一个对应的复核赋值运算符（比如`-`对应`-=`、`+`对应`+=`），此时利用 对应的复核赋值运算符 来实现 该算术运算符是最方便的。

### 5.3 为`Sales_data`类定义 `+`运算符
#### &emsp;(1) 形参和返回值
**形参**
&emsp;&emsp; `+`运算符 肯定是接收两个 `Sales_data`对象，而且相加是不会改变实参的值的，因此用 const比较合适。
**返回值**
#### &emsp;(2) 定义
&emsp;&emsp; 算术运算符 一般是计算得到一个新值，这个值一般是一个局部变量，运算完成后一般返回这个局部变量的副本。
&emsp;&emsp; 一般来说，如果一个类定义了算术运算符，那么他一般也会定义一个对应的复合赋值运算符，在这种情况下，最有效的方法是使用复核赋值来定义算术运算符。
```cpp
Sales_data operator+(const Sales_data &lhs, const Sales_data &rhs)
{
    Sales_data sum = lhs;   // 将lhs拷贝给临时变量sum
    sum += rhs;         // 利用 += 运算符来完成工作，节省代码量（这个在后面会定义）
    return sum;
}
```






&emsp;
&emsp;
## 6. 重载相等运算符
### 6.1 定义 相等运算符 的时候有什么设计准则？
&emsp;&emsp; 
> (1) 如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成`operator==` 而非一个 普通的命名函数（如equal()）：因为用户比较习惯于通过使用`==`来比较对象，所以提供了`==`就意味着用户无需再费时费力地学习并记忆一个全新的函数名字。此外，**类定义了`==`运算符之后也更容易使用标准库容器和算法**。
> (2) 如果类定义了`operator==`，则该运算符应该能判断一组给定的对象中是否含有重复的数据。
> (3) 通常情况下，相等运算符应该具有传递性，换句话说，如果`a==b`和`b==c`都为真，则`a==c`也应该为真。
> (4) 如果类定义了`operator==`，则这个类也应该定义`operator!=`。因为对于用户来说，当他们能使用`==`
> (5) **相等运算符和不相等运算符中的一个 应该把工作委托给另外一个，这意味着其中一个运算符应该负责实际的比较工作，而另一个运算符则只是调用哪个真正工作的运算符**。
> 
### 6.2 为`Sales_data`类定义 `==` 和 `!=`
&emsp;&emsp; 其实只需要定义 `==`就行了，因为 `!=`可以通过调用`!=`来实现功能。
```cpp
bool operator==(const Sales_data &lhs, const Sales_data &rhs)
{
    return lhs.isbn() == rhs.isbn() && 
            lhs.units_sold == rhs.units_sold && 
            lhs.revenue == rhs.revenue ;
}

bool operator!=(const Sales_data &lhs, const Sales_data &rhs)
{
    return !(lhs == rhs);
}
```






&emsp;
&emsp;
## 7. 重载 关系运算符
### 7.1 对于 关系运算符，应该将其定义为 成员函数 还是 非成员函数？ 为什么？
&emsp;&emsp; 和算术运算符一样，我们通常应该将 关系运算符 定义为 非成员函数，这样左侧、右侧的运算对象就能互相转换了，要不然左侧就必须是该对象，具体的分析见前面`string`类的`+`运算符的例子。

### 7.2 `>` 和 `<` 应该优先定义哪个？
&emsp;&emsp; 应该优先定义 小于号，因为很多容器和算法会用到它。

通常情况下，关系运算符应该：
> (1) 定义顺序关系，令其与关联容器中对关键字的要求一致，并且
> (2) 如果类同时含有`==`运算符的话，则定义一种关系令其与`==`保持一致。特别是，如果两个对象是`!=`的，那么一个对象应该`<`另一个。

### 7.3 为`Sales_data`类定义 `>` 和 `<`
&emsp;&emsp; 对Sales_data类来说，关系运算符没有什么必要，因为语义上违直觉。






&emsp;
&emsp;
## 8. 赋值运算符
### 8.1 我们应该定义哪些赋值运算符？
&emsp;&emsp; 看需求，基本的有：拷贝赋值运算符、移动赋值运算符，如果需要，可以定义其它的赋值运算符，以使用别的类型作为右侧运算对象。
&emsp;&emsp; 举个例子，除 拷贝赋值运算符、移动赋值运算符 之外，标准库`vector`类 还定义了第三种赋值运算符，该运算符接收花括号内的元素作为参数，这使得我们能以这种形式使用该运算符：
```cpp
vector<string> vec;
vec = {"Hello", "World", ","};
```

### 8.2 定义赋值运算符的时候应该注意什么？
(1) 和 内置的赋值运算符 一样，自定义的赋值运算符应该返回其左侧对象的引用；
(2) 在重载赋值运算符时，不管形参的类型是什么，赋值运算符都应该定义为成员函数，因为`this指针`会绑定到`=`左侧对象中，而要调用 一个类的赋值运算符 给一个对象赋值，那这个对象的类型肯定是这个类。

### 8.3 为 `StrVec`类 提供一个 赋值运算符，它接收 花括号内的元素作为参数
&emsp;&emsp; 和拷贝赋值运算符一样，要和 内置的赋值运算符 保持一致，这个新的赋值运算符应该返回其左侧对象的引用：
```cpp
class StrVec {
public:
    StrVec &operator=(std::initializer_list<std::string>);
    // 其它成员

StrVec &StrVec::operator=(initializer_list<string> il)
{
    auto data = alloc_n_copy(il.begin(), il.end());
    free(); 
    elements = data.first; 
    first_free = cap = data.second;
    return *this;
}
```

### 8.4 为 `Sales_data`类定义 复核运算符`+=`
#### 8.4.1 `+=`运算符 应该定义为 成员函数还是非成员函数？
&emsp;&emsp; 和`+`运算符 必须是非成员函数 不一样，`+=`运算符可以是 非成员函数，也可以是 成员函数，但一般倾向于将其定义为 成员函数，这样就可以把所有 赋值操作相关的运算符 都统一定义为 成员函数。
#### 8.4.2 定义
&emsp;&emsp; 和 内置的 复核赋值运算符 保持一致，此复核赋值运算符 也应该返回其左侧对象的引用：
```cpp
Sales_data& operator+=(const Sales_data&rhs)
{
    units_sold += rhs.units_sold;
    revenue += rhs.revenue ;
    return *this;
}
Sales_data& Sales_data::operator+=(const Sales_data &rhs)
{
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;
}
```






&emsp;
&emsp;
## 9. 下标运算符
### 9.1 重载 下标运算符时需要注意的是？
(1) 下标运算符 **必须是** 成员数函
(2) 返回值应该是访问元素的引用（这是为了和下标的原始定义兼容）
(3) 应该定义两个版本：常量版本 和 非常量版本
&emsp;&emsp; 常量版本的下标运算符 保证了： 当作用于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值。

### 9.2 给 `StrVec`类 提供 下标运算符
```cpp
class StrVec {
public:
    std::string& operator[](std::size_t n)
            { return elements[n]; }
    const std::string& operator[](std::size_t n) const
            { return elements[n]; }
    // other members as in § 13.5 (p. 526)
private:
    std::string *elements; // pointer to the first element in the array
};
```






&emsp;
&emsp;
## 9. 递增、递减 运算符
### 9.1 它们应该是成员函数 还是 非成员函数？
&emsp;&emsp; C++并未规定 递增、递减 运算符 必须是类的成员，但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为 成员函数。

### 9.2 重载 递增、递减 运算符 是要注意什么？
(1) 建议将其设定为 成员函数；
(2) 应该同时提供前置版本 和 后置版本
(3) 只定义前置版本，后置版本调用对应的前置版本即可。
(4) 为了与内置版本保持一致，前置版本应该返回 递增(递减)后对象的引用，后置版本应该返回原值

### 9.3 前置、后置 递增(递减)运算符的返回值应该是？
应该和他们对应的内置版本保持一致：
> 前置版本：返回 递增(递减)后对象的引用
> 后置版本：返回原值

### 9.4 编译器 如何区分 前置和后置 递增(递减)运算符？
&emsp;&emsp; 在同时定义 前置和后置 递增(递减)运算符 时，普通的重载形式是无法区分该 递增(递减)运算符 到底是 前置版本 还是 后置版本的，因为它们使用的是同一个运算符号，而且形参列表也一样。
&emsp;&emsp; ，**为了解决这个问题**，后置版本可以接受一个 额外的(不被使用的) `int`类型的形参。当我们使用后置运算符时，编译器为这个形参提供一个值为0的实参。尽管从语法上说后置函数可以使用这个额外的形参，但在实际过程中通常不会这么做，这个形参唯一的作用就是区分 前置版本和后置版本的函数。
```cpp
class StrBlobPtr {
public:
    // increment and decrement

    StrBlobPtr& operator++(); // prefix operators
    StrBlobPtr& operator--();

    StrBlobPtr operator++(int); // postfix operators
    StrBlobPtr operator--(int);
    // other members as before
};
```

### 9.5 为下面的`Time`类定义 递增、递减 运算符
#### 9.5.1 `Time`类
```cpp
class Time
{
private:
    int hours;             // 0 到 23
    int minutes;           // 0 到 59
public:
    // 默认构造函数
    Time(int h = 0, int m = 0):hours(h),minutes(m) { }
    // Time(int h , int m):hours(h),minutes(m) { }

    Time& operator++();
    Time& operator--();

    // 后置版本的 递增(递减)运算符
    Time operator++(int);
    Time operator--(int);

    // 显示时间的方法
    void displayTime() { cout << "H: " << hours << " M:" << minutes <<endl;}
};
```
#### 9.5.2 定义 递增、递减 运算符
```cpp
Time& Time::operator++() 
{
    ++minutes;
    if(minutes >= 60){
        ++hours;
        minutes -= 60;
    }
    return *this;
}

Time& Time::operator--()
{
    --minutes;
    if(minutes < 0){
        if (hours <= 0){
            cout << "Erro" <<endl;
            hours = minutes = 0;
        }
        --hours;
        minutes += 60;
    }    
    return *this;
}

// 后置版本调用对应的前置版本即可
Time Time::operator++(int) // 此时形参不需要命名，因为我们不会使用该参数
{
    Time ret = *this;
    ++*this; 
    return ret;
}

Time Time::operator--(int)
{
    Time ret = *this;
    --*this;
    return ret;
}
```
#### 9.5.3 测试
```cpp
int main()
{
    Time t1(1, 59);
    ++t1;
    t1.displayTime();
    (--t1).displayTime();
    
    (t1--).displayTime();
    t1.displayTime();

    (t1++).displayTime();
    t1.displayTime();
    return 0;
}

```
运行结果：
> H: 2 M:0
> H: 1 M:59
> H: 1 M:59
> H: 1 M:58
> H: 1 M:58
> H: 1 M:59






&emsp;
&emsp;
## 10. 成员访问运算符
### 10.1 箭头运算符(->) 和 解引用运算符(*) 应该定义为 成员函数 还是 非成员函数？
&emsp;&emsp; 箭头运算符(->)**必须是**类的成员；
&emsp;&emsp; 虽然并没有强制规定，但解引用运算符(*) 通常也是类的成员。

### 10.2 箭头运算符(->) 和 解引用运算符(*) 的返回值有何限定？
&emsp;&emsp; 解引用运算符(*) ，我们可以令 `operator*` 完成我们任何指定的操作。换句话说，我们可以让 `operator*` 返回一个固定值如`Hello World`，或则打印对象的内容等等，但还是建议和内置的类型保持一致（即返回指针所指向对象）。
&emsp;&emsp; 箭头运算符(->)则不是这样的，它永远不能丢掉成员访问这个最基本的含义，也就是说 在重载箭头运算符时，可以改变的是箭头从哪个对象中获取成员，而 箭头运算符是用来获取成员的 这一事实永远不会变。**换句话说，箭头运算符(->)的返回值必须是：**
> 类的指针
> 自定了箭头运算符的某个类的对象

### 10.3 表达式 `point->mem` 有哪几种解释？
**(1) 若`point`是 内置指针**
&emsp;&emsp; 因为`point`是 内置指针，则我们使用的是 内置的箭头运算符，则该表达式等价于`(*point).mem`：先解引用指针`point`，然后从它指向的对象中获取成员`mem`，若`point`指向的类型没有名为`mem`的成员，则程序会发生错误。
**(2) 若`point`是 定义了`operator->`的类的对象**
&emsp;&emsp; 若`point`是 定义了`operator->`的类的对象，则我们使用`point.operator->()`的 返回结果 来获取`mem`，此时有两种情况：
> 如果 该返回结果是一个指针，则执行 前面的 第(1)步；
> 如果 该返回结果 本身含有重载的的 `operator->()`，则重复调用当前步骤。
>   
在这一系列过程结束时，程序可能返回了所需的内容，也可能返回一些表示程序错误的消息。

### 10.4 在下面的代码中，为什么同样是`->foo`，得到的结果却不一样呢？
```cpp
include <string>
#include <iostream>

using namespace std;

struct A { 
    string foo = "I am in struct A"; 
};

struct B { 
    A a;
    A *operator->() { return &a; } // 这里返回的是 a成员 的地址
};

struct C { 
    B b;  
    B operator->() { return b; } 
};

struct D { 
    C c;
    string foo = "Hello,it's struct D";
    C operator->() { return c; }
};

int main()
{
    D d1;
    cout << d1->foo << endl;
    D *d2 = &d1;
    cout << d2->foo << endl;
    return 0;
}

```
运行结果：
> [zhangsan@localhost code]$ ./test.o 
> I am in struct A
> Hello,it's struct D
#### &emsp; 10.4.1 `cout << d1->foo << endl;` 的运行原理是？
&emsp;&emsp; 箭头运算符的实现，是用循环来做的，会反复调用operator->()直到返回值是一个指针。
&emsp;&emsp; 对于`d1->foo`来说，因为 对象`d1`的类型是 `D`类，因此在对`d1`调用 箭头运算符`->`时，调用的是其实是`C operator->() { return c; }`，然后它返回 `D`类的的成员`c`，然后循环调用直到获取到 类A的成员`foo`，详细的调用过程是这样的：
> 第一步：`d1->foo`调用`D::operator->()`得到 `D`类的成员`c`；
> 第二步：对上一步得到的 `D`类的成员`c`调用 `C::operator->()` 得到 `C`类的成员`b`；
> 第三步：对上一步得到的 `C`类的成员`b`调用 `B::operator->()` 得到 一个指向`B`类的成员`a`的指针；
> 第三步：因为 上一步得到的是 一个指向`B`类的成员`a`的指针，因此对它调用`->foo`，最终在屏幕中输出 `I am in struct A`
> 
也就是说，当`d`不是指针的时候，编译器会不停的调用`d`的`operator->()`直到他变成一个指针，然后才调用`->foo`获得其成员。换句话说，`d1->fo`在经过编译后的代码应该差不多是这样的:
```cpp  
*d.operator->().operator->().operator->()).foo; 
```
或者:
```cpp 
d.operator->().operator->().operator->()->foo; // 这里foo前面是 箭头运算符(->)，上面那个是 点运算符(.)
```
#### &emsp; 10.4.2 `cout << d2->foo << endl;`的运行原理是？
&emsp;&emsp; 首先，`d2`是一个内置指针，它指向的是 对象`d1`，因此`d2->foo`其实调用的是内置指针的`->`，而不是`D::operator->()`，因此`d2->foo`访问的是 `D::foo`，而不是`A::foo`，因此输出结果为`Hello,it's struct D`。






&emsp;
&emsp;
## 11. 函数调用运算符
### 11.1 函数调用运算符 应该是成员函数还是非成员函数？
&emsp;&emsp; 函数调用运算符`()` **必须是成员函数**

### 11.2 一个类可以定义几个函数调用运算符？
&emsp;&emsp; 一个类可以定义多个函数调用运算符，形参不一样即可（和函数重载一样）。

### 11.3 定义一个 重载了函数调用运算符的类`absInt`，它返回`int`实参的绝对值，并编写测试案例
```cpp
struct absInt {
    int operator()(int val) const {
        return val < 0 ? -val : val;
}
};

int i = -42;
absInt absObj;      // absObj 是一个含有函数调用运算符的对象
int ui = absObj(i); // 将 i 传给 absObj.operator()
```

### 11.4 重载了函数调用运算符的类 相比于 普通的函数 有什么优势呢？
&emsp;&emsp; 相比于  普通的函数，重载了函数调用运算符的类 同时能存储状态，所以比普通函数更加灵活。

### 11.5 含有状态的 函数对象类 `PrintString`

```cpp
class PrintString {
public:
    PrintString(ostream &o = cout, char c = ' '): os(o), sep(c) { }
    void operator()(const string &s) const { os << s << sep; }
private:
    ostream &os; // stream on which to write
    char sep;    // character to print after each output
};
```




&emsp;
&emsp;
## 12. 函数调用运算符
### 12.1 什么是 函数对象(function object)？
&emsp;&emsp; 如果类定义了 函数调用运算符`()`，则 该类的对象 称为 函数对象。因为我们可以调用这种对象，所以我们说这些对象的 “行为像函数一样”。




&emsp;
&emsp;
## 为什么有的运算符只能是成员函数？
 https://zhuanlan.zhihu.com/p/184766356    TODO:

https://r00tk1ts.github.io/2018/11/29/C++%20Primer%20-%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/

