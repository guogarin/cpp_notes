## 1. 引用折叠(reference collapsing)
### 1.1 什么是引用折叠？
&emsp;&emsp; (根据《C++ primer》6.2.5节的描述) 当我们 间接创建一个 **引用的引用** 时，这些引用会形成“折叠”，根本原因是因为C++中禁止reference to reference，所以编译器需要对四种情况(也就是L2L,L2R,R2L,R2R)进行处理，将他们“折叠”(也可说是“坍缩”)成一种单一的reference，折叠规则如下：
 类型 | 折叠后 | 
 ---------|----------|
 `X& &、X & && 、X && &` | `X &` | 
 `X && &&`               | `X &&` | 

对于折叠规则，知乎网友`Wang Shuai`总结的很精辟：
> 就是左值引用会传染，只有纯右值&& && = &&，沾上一个左值引用就变左值引用了。
> 

### 1.2 对于下面的代码，它们的类型分别是什么？
```cpp
using Lref = Data&;
using Rref = Data&&;
Data data;

Lref&  r1 = data;  
Lref&& r2 = data;  
Rref&  r3 = data;  
Rref&& r4 = Data{};
```
根据引用折叠的规则，很容易得到：
```cpp
Lref&  r1 = data;    // r1 is Data&
Lref&& r2 = data;    // r2 is Data&
Rref&  r3 = data;    // r3 is Data&
Rref&& r4 = Data{};  // r4 is Data&&
```

### 1.3 为什么要这么麻烦，直接创建引用的引用不就行了吗？
不行，因为C++不允许创建引用的引用：
```cpp
int a = 0;
int &ra = a;
int & &rra = ra;  // 编译器报错：不允许使用引用的引用！
```

### 1.4 引用折叠 存在的意义是？
引用折叠是移动转发`std::move()` 和 完美转发`std::forward()` 的实现基础。
TODO: 为什么是它们的基础？






&emsp;
&emsp;
## 2. 万能引用(universal reference)
### 2.1 什么是万能引用？为什么叫万能引用？
&emsp;&emsp; 所谓的万能引用并不是C++的语法特性，而是我们利用现有的C++语法，自己实现的一个功能。因为这个功能既能接受左值类型的参数，也能接受右值类型的参数。所以叫做万能引用。

### 2.2 







&emsp;
&emsp;
## 参考文献

1. [C++ 引用折叠和右值引用参数](https://blog.csdn.net/Rengachan/article/details/109997911)
2. [现代C++之万能引用、完美转发、引用折叠](https://zhuanlan.zhihu.com/p/99524127)
3. [引用折叠和完美转发](https://zhuanlan.zhihu.com/p/50816420)
4. [谈谈完美转发(Perfect Forwarding)：完美转发 = 引用折叠 + 万能引用 + std::forward](https://zhuanlan.zhihu.com/p/369203981)
5. [如何理解c++中的引用折叠?](https://www.zhihu.com/question/40346748)