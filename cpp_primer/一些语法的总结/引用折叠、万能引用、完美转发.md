## 1. 引用折叠(reference collapsing)
### 1.1 什么是引用折叠？
&emsp;&emsp; (根据《C++ primer》6.2.5节的描述) 当我们 间接创建一个 **引用的引用** 时，这些引用会形成“折叠”，根本原因是因为C++中禁止reference to reference，所以编译器需要对四种情况(也就是L2L,L2R,R2L,R2R)进行处理，将他们“折叠”(也可说是“坍缩”)成一种单一的reference，折叠规则如下：
 类型 | 折叠后 | 
 ---------|----------|
 `X& &、X & && 、X && &` | `X &` | 
 `X && &&`               | `X &&` | 

对于折叠规则，知乎网友`Wang Shuai`总结的很精辟：
> 就是左值引用会传染，只有纯右值&& && = &&，沾上一个左值引用就变左值引用了。
> 

### 1.2 习题
#### 1.2.1 对于下面的代码，它们的类型分别是什么？
```cpp
using Data = int;
using Lref = Data&;
using Rref = Data&&;

Data data;

int main()
{
    Lref&  r1 = data;  
    Lref&& r2 = data;  
    Rref&  r3 = data;  
    Rref&& r4 = Data{};
}

```
根据引用折叠的规则，很容易得到：
```cpp
Lref&  r1 = data;    // r1 is Data&
Lref&& r2 = data;    // r2 is Data&
Rref&  r3 = data;    // r3 is Data&
Rref&& r4 = Data{};  // r4 is Data&&
```
#### 1.2.2 上面为什么要使用`using`来定义别名呢？直接创建引用的引用不就行了吗？
不行，因为C++不允许创建引用的引用：
```cpp
int a = 0;
int &ra = a;
int & &rra = ra;  // 编译器报错：不允许使用引用的引用！
```
编译后运行，报错如下：
```
temp.cpp: In function ‘int main()’:
temp.cpp:10:12: error: cannot declare reference to ‘int&’, which is not a typedef or a template type argument
     int & &rra = ra; 
            ^
```
上面的报错信息翻译过来就是： 不能声明一个到`int&`的引用（即引用的引用），除非是使用`typedef或using`或模板形参

### 1.4 引用折叠 在哪些场景下会发生？
**① 调用模板参数时**
```cpp
template<typename T>
void f(T&& param);
  
int x;

f(10);    // invoke f() on rvalue
f(x);     // invoke f() on lvalue
```
当用 右值`10` 调用 `f()` 的时候, `T`被推导为 `int`，实例化的 `f()` 看起来像这样:
```cpp
void f(int&& param);      // f instantiated from rvalue
```
这里一切都OK。但是当我们用 左值`x` 来调用 `f()` 的时候，`T` 被推导为`int&`，而实例化的 `f()` 就包含了一个引用的引用:
```cpp
void f(int& && param);   // initial instantiation of f with lvalue
```
因为这里出现了引用的引用，这实例化的代码乍一看好像不合法，但根据C++11引入的 引用折叠(reference collapsing)规则，编译器将上面的调用处理成了：
```cpp
void f(int& param);      // instantiation of f with lvalue after reference collapsing
```

**② 使用`auto`推导类型时**
```cpp
int&& var1=10;
auto&& var2 = var1;
```
&emsp;&emsp; var1 的类型是 `int&&`，但是它的 右值属性 在推导 `var2` 的类型的时候被忽略了，因此`var1`这时候就被当做`int`。因为`var1`被当成了一个左值(即`int`)，因此在初始化万能引用`var2`的时候，`var1`的类型就被推导为`int&`，在`var2`的定义中将`auto`替换为`int&`，即`auto&& var2 = var1;`就相当于：
```cpp
int& && var2 = var1;
```
根据引用折叠的规则，就变成了：
```cpp
int& var2 = var1;
```

**③ 使用 `typedef`或`using` 时**
本文1.2小节的代码就是例子。

**④ 使用 `decltype`时**


### 1.5 引用折叠 存在的意义是？
引用折叠是移动转发`std::move()` 和 完美转发`std::forward()` 的实现基础。
TODO: 为什么是它们的基础？






&emsp;
&emsp;
## 2. 万能引用(universal reference)
### 2.1 什么是万能引用？为什么叫万能引用？
&emsp;&emsp; 所谓的万能引用并不是C++的语法特性，而是我们利用现有的C++语法，自己实现的一个功能。
&emsp;&emsp; 因为这个功能 既能接受左值类型的参数，也能接受右值类型的参数。所以叫做万能引用。

### 2.2 为什么会有万能引用 这个特性？
&emsp;&emsp; 从语法上来看，声明右值引用看起来和声明"普通"的引用(即左值引用(lvalue references))很像，只不过你需要用`&&`而不是`&`。下面这个函数需要一个类型为rvalue-reference-to-Widget:的参数:
```cpp
void f(Widget&& param);
```
假设右值引用是使用`&&`声明的，那么假设类型声明中出现`&&`时 表示右值引用似乎是合理的。然而事实并非如此:
```cpp
Widget&& var1 = someWidget;      // here, “&&” means rvalue reference
 
auto&& var2 = var1;              // but here, “&&” does not mean rvalue reference
 
template<typename T>
void f(std::vector<T>&& param);  // here, “&&” means rvalue reference
 
template<typename T>
void f(T&& param);               // but here, “&&”does not mean rvalue reference
```
从上面的代码我们可以知道，`&&`可能具有两种含义：
> 有的时候意味着rvalue reference，
> 但有的时候意味着rvalue reference 或者 lvalue reference
> 
因此，源代码当中出现的 “&&” 有可能是 “&” 的意思，即是说，语法上看着像rvalue reference (“&&”)，但实际上却代表着一个lvalue reference (“&”)。在这种情况下，此种引用比lvalue references 或者 rvalue references都要来的更灵活:
> Rvalue references只能绑定到右值上;
> lvalue references除了可以绑定到左值上，**在某些条件下**还可以绑定到右值上,这里的某些条件绑定右值为：常左值引用绑定到右值，非常左值引用不可绑定到右值！（这个例外详见第二章的笔记）：
> 
**综上所述，** 之所以会有万能引用，就是因为`&&`可能具有上面所说的两种含义。

### 2.3 什么时候才会出现 万能引用 呢？
对于万能引用，需要牢记下面的原则：
> If a variable or parameter is declared to have type T&& for some deduced type T, that variable or parameter is a universal reference.
> 如果一个变量或者参数被声明为`T&&`，其中`T`是被推导的类型，那这个变量或者参数就是一个universal reference。
> 
"**T需要是一个被推导类型**"这个要求限制了universal references的出现范围。
&emsp;&emsp; 在实践当中，几乎所有的universal references都是 函数模板的参数。但因为`auto`声明的变量的类型推导规则本质上和模板是一样的，所以使用`auto`的时候你也可能得到一个universal references。
**总结：**
综上所述，形式严格为`T&&`（不可以有`const`等额外的限定词），并且类型`T`需要经过类型系统推导而来。也就是说，万能引用必须同时满足下面两个条件：
> ① 形式严格为`T&&`(不能有额外的限定词，即使是`const`也不行！)
> ② 需要经过类型系统推导而来
> 
因此，万能引用只会出现在下面两种情况下：
> ① 函数模板的参数
> ② 使用`auto`的时候(因为`auto`推导等价于模板类型推导)
> 
例如下面的代码：
```cpp
template<typename T>
void f(T&& param);          // param是万能引用

auto&& var2 = var1;         // var2是个万能引用，因为auto推导等价于模板类型推导
int && ref = 6;             // 不是万能引用
```

### 2.4 如何区分 是不是万能引用？
**① 形式上，如果不是`T&&`，则一定不是万能引用。**
```cpp
template<typename T>
void f(std::vector<T>&& param);
```
上述代码中，尽管类型`T`要经过类型推导，但是其形式不是`T&&`，而是`std::vector<T>&&`，这就表明，`param`是个右值引用，而不是万能引用。
**② 类型没有涉及推导的话，则一定不是万能引用。**
```cpp
template<typename T, typename Allocator = allocator<T>>
class vector{
    public:
    void push_back(T&& x);
};
```
`std::vector`的成员函数`push_back`的一个重载形式如上，但是参数`x`仍然不是万能引用，因为`T`不涉及类型推导，当具体的`vector`被实例化以后，`T`的类型便被具体确定。
```cpp
template<typename T, typename Allocator = allocator<T>>
class vector{
    public:
    template<typename... Args>
    void emplace_back(Args&&... args);
};
```
而`vector`的成员函数`emplace_back`的函数参数`args`（实际上为参数包，但是不影响），则确定为万能引用，因为每次调用都会推导其参数类型，并且形式严格遵循`T&&`形式。

### 2.5 对于一个万能引用来说，如何确定它在被实例化后代表的是 左值 还是 右值？
&emsp;&emsp; 和所有的引用一样，你必须对万能引用进行初始化，而且正是万能引用的initializer决定了它到底代表的是lvalue reference 还是 rvalue reference:：
> 如果用来初始化 万能引用 的表达式是一个左值，那么万能引用就变成 lvalue reference。
> 如果用来初始化 万能引用 的表达式是一个右值，那么万能引用就变成 rvalue reference。
> 
上述可以根据下面代码例子理解：
```cpp
template<typename T>
void f(T&& param); 

int a;
f(a);   // 传入左值,那么上述的T&& 就是lvalue reference
f(1);   // 传入右值,那么上述的T&& 就是rvalue reference
```

### 2.6 万能引用 这个特性 的作用是什么？
&emsp;&emsp; 为完美转换提供了基础。TODO:

### 2.7 关于区分左值、右值的几个小例子
### 2.7.1 下面几个变量`var1、var2、var3、var4、var5`是什么引用？属于万能引用吗？绑定到它们的是 左值还是右值呢？
```cpp
int main()
{
    int a = 0;
    int&& var1 = a;
    int& var2 = a;
    auto&& var3 = var2;
    auto&& var4 = std::move(var2);
    
    std::vector<int> v = {0, 2, 3};
    auto&& var5 = v[0];    
    return 0;
}
```
**var1**
这个语句是错误的，因为我们不能将一个左值绑定到一个右值引用上，报错信息如下：
```
test.cpp: In function ‘int main()’:
test.cpp:13:18: error: cannot bind ‘int’ lvalue to ‘int&&’
     int&& var1 = a;
                  ^
```
**var2**
&emsp;&emsp; `var2`是一个左值引用，既然是左值引用，那就肯定不是万能引用了，左值`a`绑定到它上面。
**var3**
&emsp;&emsp; `var3`是一个左值引用，而且声明的类型为`auto&&`，所以它是万能引用，但它绑定的对象`var2`是一个左值，因此根据引用折叠规则，`var3`的最终类型为 `int&`，
**var4**
&emsp;&emsp; `var4`是一个右值引用，而且声明的类型为`auto&&`，所以它是万能引用，但它绑定的对象`std::move(var2)`返回的是一个右值，因此根据引用折叠规则，`var4`的最终类型为 `int&&`，
**var5**
&emsp;&emsp; `var5`是一个左值引用，而且声明的类型为`auto&&`，所以它是万能引用，，但它绑定的对象`v[0]`是一个左值引用，因此根据引用折叠规则，`var`的最终类型为 `int&`。
### 2.7.2 形参`param` 是万能引用吗？那在下面这个函数中，绑定到 形参`param` 是左值还是右值呢？
```cpp
template<typename T>
void f(T&& param);
f(10);
int x = 10;
f(x);
```
**f(10);**
&emsp;&emsp; `param` 被字面值10初始化，因为你不能对字面值取址，所以10是一个rvalue。这就意味着上面对f的调用当中，universal reference `param`被一个rvalue初始化，所以 `param` 就变成了rvalue reference – 具体来讲，就是 `int&&`。
**f(x);**
&emsp;&emsp; `param`被变量 x 初始化，因为你能对 `x` 取址，所以`x`是个lvalue。这就是说，这里对f的调用，universal reference `param`被一个lvalue初始化，因此`param`就变成lvalue reference – 准确的说，就是`int&`。
### 2.7.3 下面几个带`&&`的形参是 万能引用吗？为什么？
分辨`&&`型的参数是否万能引用，只要牢记下面的准则即可：
> 只有在**发生类型推导时**，`&&` 才代表 universal reference，如果没有类型推导，就没有universal reference。这种时候，类型声明当中的`&&`总是代表着 rvalue reference。
> 
#### (1) 下面的函数的形参是万能引用吗？为什么？
```cpp
template<typename T>
void f(T&& param);               
                                 
template<typename T>
class Widget {
    ...
    Widget(Widget&& rhs);   
    ...                     
};
 
template<typename T1>
class Gadget {
    ...
    template<typename T2>
    Gadget(T2&& rhs);            
    ...                          
};
 
void f(Widget&& param);
```
**解答：**

```cpp
// 是万能引用，因为满足万能引用的两个要求：① 形如 T&& 或 auto&&; ② 需要推导 
template<typename T>
void f(T&& param);              
                                 
template<typename T>
class Widget {
    ...
    // 不是万能引用，而是普通的右值引用，因为形参rhs的类型是确定的，不需要推导
    Widget(Widget&& rhs);   
    ...                     
};
 
template<typename T1>
class Gadget {
    ...
    // 是万能引用，因为满足万能引用的两个要求：① 形如 T&& 或 auto&&; ② 需要推导
    template<typename T2>
    Gadget(T2&& rhs);         
    ...                          
};

// 不是万能引用，而是普通的右值引用，因为形参param的类型是确定的，不需要推导
void f(Widget&& param);  
```
#### (2) 下面这个函数模板中，形参是万能引用吗？为什么？
```cpp
template<typename T>
void fun(std::vector<T>&& param); 
```
**解答：**
&emsp;&emsp; 在上面的 函数模板`fun`中，既有`&&`，又有类型推导，看起来也应该是一个万能引用，但遗憾的是，它不是`T&&`，而是 `std::vector<t>&&`。其结果就是，参数就只是一个普通的rvalue reference，而不是universal reference。 Universal references只以 `T&&` 的形式出现！即便是仅仅加一个`const限定符`都会使得`&&`不再被解释为universal reference。也就是说，上面的`param`参数并不是一个万能引用，而是一个普通的 右值引用。
#### (3) 下面这个函数模板中，形参是万能引用吗？为什么？
```cpp
template<typename T>
void f(const T&& param);
```
**解答：**
&emsp;&emsp; 万能引用必须形如 `T&&` 或 `auto&&`，即使仅仅加一个`const限定符`都会使得`&&`不再被解释为universal reference。也就是说，上面的`param`参数并不是一个万能引用，而是一个普通的 右值引用。
#### (4) 下面这个函数模板中，形参是万能引用吗？为什么？
```cpp
template<typename MyTemplateParamType>
void f(MyTemplateParamType&& param); 
```
**解答：**
&emsp;&emsp; 是万能引用，形如`T&&` 并不是说你的模板参数非得要用`T`，用其它的别名代替也是可以的。
#### (5)下面这个类模板的成员函数中，形参是万能引用吗？为什么？
```cpp
template <class T, class Allocator = allocator<T> >
class vector {
public:
    ...
    void push_back(T&& x);      
    ...                         
};
```
**解答：**
&emsp;&emsp; 不是万能引用，`vector::push_back`确实是形如`T&&`，但是`T`不需要推导，这是定义一个`vector`对象的时候用户提供的，如：`vector<int> vec;`，这里的`T`的类型是`int`，因此`vector::push_back`就无需再推导`T`的类型，因为用户已经提供了。因此它不是万能引用。
#### (6) 下面这个类模板的成员函数中，形参是万能引用吗？为什么？
```cpp
template <class T, class Allocator = allocator<T> >
class vector {
public:
    ...
    template <class... Args>
    void emplace_back(Args&&... args); 
    ...                                
};
```
**解答：**
&emsp;&emsp; `这个是万能引用，emplace_back` 看起来需要多个参数(`Args`和`args`的声明当中都有...)，但重点是每一个参数的类型都需要进行推导。函数的模板参数 `Args` 和类的模板参数`T`无关，所以即使我知道这个类具体是什么，比如说，std::vector<Widget>，但我们还是不知道`emplace_back`的参数类型是什么，因此我们需要根据具体调用来推导`Args`和`args`等的类型。







&emsp;
&emsp;
## 3. 表达式的左右值性与类型无关
&emsp;&emsp; “值类别”（value category）和“值类型”（value type）是两个看似相 似、却毫不相干的术语。前者指的是上面这些左值、右值相关的概念，后者则是与引用类型（reference type）相对而言，表明一个变量是代表实际数值，还是引用另外一个数值。在C++ 里，所有的原生类型、枚举、结构、联合、类都代表值类型，只有引用（&）和指针（*）才是引用类型。在 Java 里，数字等原生类型是值类型，类则属于引用类型。在Python 里，一切类型都是引用类型。
&emsp;&emsp; 一个表达式的lvalueness (左值性)或者 rvalueness (右值性)和它的类型无关。
&emsp;&emsp; 来看下 int。可以有lvalue的int (e.g., 声明为int的变量)，还有rvalue的int (e.g., 字面值10)。用户定义类型Widget等等也是一样的。
&emsp;&emsp; 一个Widget对象可以是lvalue(e.g., a Widget 变量) 或者是rvalue (e.g., 创建Widget的工程函数的返回值)。
&emsp;&emsp; 表达式的类型不会告诉你它到底是个lvalue还是rvalue。因为表达式的 lvalueness 或 rvalueness 独立于它的类型，我们就可以有一个 lvalue，但它的类型确是 rvalue reference，也可以有一个 rvalue reference 类型的 rvalue :
```cpp
Widget makeWidget();                       // factory function for Widget
 
Widget&& var1 = makeWidget()               // var1 is an lvalue, but
                                           // its type is rvalue reference (to Widget)
 
Widget var2 = static_cast<Widget&&>(var1); // the cast expression yields an rvalue, but
                                           // its type is rvalue reference  (to Widget)
```                                           
&emsp;&emsp; var1类别是左值，但它的类型是右值引用。static_cast<Widget&&>(var1)表达式是个右值，但它的类型是右值引用。
&emsp;&emsp; 把 lvalues (例如 var1) 转换成 rvalues 比较常规的方式是对它们调用std::move，所以 var2 可以像这样定义:
```cpp
Widget var2 = std::move(var1);             // equivalent to above
```
&emsp;&emsp; 我最初的代码里使用 static_cast 仅仅是为了显示的说明这个表达式的类型是个rvalue reference (Widget&&)。rvalue reference 类型的具名变量和参数是 lvalues。(你可以对他们取地址。)
&emsp;&emsp; 我们再来看下前面提到的 Widget 和 Gadget 模板:
```cpp
template<typename T>
class Widget {
    ...
    Widget(Widget&& rhs);        // rhs’s type is rvalue reference,
    ...                          // but rhs itself is an lvalue
};
 
template<typename T1>
class Gadget {
    ...
    template <typename T2>
    Gadget(T2&& rhs);            // rhs is a universal reference whose type will
    ...                          // eventually become an rvalue reference or
};                               // an lvalue reference, but rhs itself is an lvalue
```
&emsp;&emsp; 在 `Widget` 的构造函数当中, `rhs` 是一个rvalue reference，前面提到，右值引用只能被绑定到右值上，所以我们知道它被绑定到了一个rvalue上面(i.e., 因此我们需要传递了一个rvalue给它)， 但是 `rhs` 本身是一个 lvalue，所以，当我们想要用到这个被绑定在 `rhs` 上的rvalue 的 rvalueness 的时候，我们就需要把 rhs 转换回一个rvalue。之所以我们想要这么做，是因为我们想将它作为一个移动操作的source，这就是为什么我们用 `std::move`将它转换回一个 rvalue。
&emsp;&emsp; 类似地，`Gadget` 构造函数当中的`rhs` 是一个 universal reference,，所以它可能绑定到一个 lvalue 或者 rvalue 上，但是无论它被绑定到什么东西上，rhs 本身还是一个 lvalue。
&emsp;&emsp; 如果它被绑定到一个 rvalue 并且我们想利用这个rvalue 的 rvalueness， 我们就要重新将 rhs 转换回一个rvalue。如果它被绑定到一个lvalue上，当然我们就不想把它当做 rvalue。
&emsp;&emsp; 一个绑定到universal reference上的对象可能具有 lvalueness 或者 rvalueness，正是因为有这种二义性，所以催生了`std::forward`：如果一个本身是 lvalue 的 universal reference 如果绑定在了一个 rvalue 上面，就把它重新转换为rvalue。函数的名字 (“forward”) 的意思就是，我们希望在传递参数的时候，可以保存参数原来的lvalueness 或 rvalueness，即是说把参数转发给另一个函数。






&emsp;
&emsp;
## 4. 万能引用 和 引用折叠 有什么关系？
&emsp;&emsp; 上面的内容精确的说明了一个 万能引用(universal reference) 是如何在经过类型推导和引用折叠之后，可以变为一个 lvalue reference的。实际上，万能引用(universal reference) 其实只是一个身处于引用折叠背景下的 右值引用(rvalue reference)。






&emsp;
&emsp;
## 5 关于万能引用 类型推导的几个习题
### 5.1 下面的代码 的运行结果是什么？为什么？
```cpp
template <typename T>
void f(T&& param){
    //static_assert(std::is_rvalue_reference<T>::value, "T& is lvalue reference.\n");
    if(std::is_lvalue_reference<T>::value)
        cout << "T& is lvalue reference." << endl;
    else
        cout << "T& is rvalue reference.\n";
    cout << std::is_lvalue_reference<T>::value << endl;
}

int main()
{
    int x;
    int &&r1 = 10;
    int &r2 = x;
    f(r1);
    f(r2);
    f(std::move(x));
}
```
**运行结果如下：**
```
T& is lvalue reference.
1
T& is lvalue reference.
1
T& is rvalue reference.
0
```
**分析解答：**
&emsp;&emsp; 我们先来看上面的几个变量的类型：根据上面的代码，`r1`是一个右值引用，`r2`是一个左值引用，模板函数`f()`的形参`param`是一个万能引用。
&emsp;&emsp; 因为`r1`是一个右值引用，因此我们下意识的认为，`T`将会被推导为`int&&`，然而情况却不是这样的，因为 `r1` 和 `r2` 的引用部分被去掉了(留下的只是 `int`)，然后，因为它们都是 lvalues 所以当调用 `f()`，对 universal reference 参数进行类型推导的时候，得到的类型都是`int&`

### 下面的代码 的运行结果是什么？为什么？
```cpp
int main()
{
    int&& var1=10;
    auto&& var2 = var1;
    cout << "var1 is_rvalue_reference: " << std::is_rvalue_reference<decltype(var1)>::value << endl;
    cout << "var2 is_rvalue_reference: " << std::is_rvalue_reference<decltype(var2)>::value << endl;
}
```
**运行结果如下：**
```
var1 is_rvalue_reference: 1
var2 is_rvalue_reference: 0
```
**分析解答：**
&emsp;&emsp; var1 的类型是 `int&&`，但是它的 右值属性 在推导 `var2` 的类型的时候被忽略了，因此`var1`这时候就被当做`int`。因为`var1`被当成了一个左值(即`int`)，因此在初始化万能引用`var2`的时候，`var1`的类型就被推导为`int&`，在`var2`的定义中将`auto`替换为`int&`，即`auto&& var2 = var1;`就相当于：
```cpp
int& && var2 = var1;
```
根据引用折叠的规则，就变成了：
```cpp
int& var2 = var1;
```





&emsp;
&emsp;
## 6 移动语义 和
&emsp;&emsp; 作为一种追求执行效率的语言，C++在用临时对象或函数返回值给左值对象赋值时的深度拷贝（deep copy）一直受到诟病。考虑到临时对象的生命期仅在表达式中持续，如果把临时对象的内容直接移动（move）给被赋值的左值对象，效率改善将是显著的。这就是移动语义的来源。
**移动语义：** 将内存的所有权从一个对象转移到另外一个对象，高效的移动用来替换效率低下的复制，对象的移动语义需要实现移动构造函数（move constructor）和移动赋值运算符（move assignment operator）。






&emsp;
&emsp;
## 7 完美转发
### 7.1 什么是完美转发？
&emsp;&emsp; 定义一个函数模板，该函数模板可以接收任意类型参数，然后将参数转发给其它目标函数，且保证目标函数接受的参数其类型与传递给模板函数的类型相同。

### 7.2 完美转发能解决什么问题？（为什么需要完美转发？）

### 7.3 完美转发 的原理是？


### 7.4 完美转发需要用到哪些特性？
[谈谈完美转发(Perfect Forwarding)：完美转发 = 引用折叠 + 万能引用 + std::forward](https://zhuanlan.zhihu.com/p/369203981)






&emsp;
&emsp;
## `std::move()` 与 `std::forward()`
### 它们有何异同？

### 实现原理





&emsp;
&emsp;
## 
## 标准库的 `emplace`操作
### 原理
https://www.jianshu.com/p/d19fc8447eaa
### 相对于`insert操作`的优势





&emsp;
&emsp;
## 参考文献
1. [C++ 引用折叠和右值引用参数](https://blog.csdn.net/Rengachan/article/details/109997911)
2. [现代C++之万能引用、完美转发、引用折叠](https://zhuanlan.zhihu.com/p/99524127)
3. [引用折叠和完美转发](https://zhuanlan.zhihu.com/p/50816420)
4. [谈谈完美转发(Perfect Forwarding)：完美转发 = 引用折叠 + 万能引用 + std::forward](https://zhuanlan.zhihu.com/p/369203981)
5. [如何理解c++中的引用折叠?](https://www.zhihu.com/question/40346748)
6. [右值引用、移动语义、万能引用与完美转发](https://zhuanlan.zhihu.com/p/188722744)
7. [深入浅出 C++ 11 右值引用](https://zhuanlan.zhihu.com/p/107445960)