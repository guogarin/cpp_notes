- [第十章 泛型算法](#第十章-泛型算法)
  - [1. 泛型算法的“泛型”指的是什么？](#1-泛型算法的泛型指的是什么)
  - [STL中的string容器的查找有几种？](#stl中的string容器的查找有几种)
  - [c++模板元编程和泛型编程是一个概念吗 ？有何异同？](#c模板元编程和泛型编程是一个概念吗-有何异同)
  - [STL算法中的求和函数是哪个？怎么用？](#stl算法中的求和函数是哪个怎么用)
  - [STL算法中查找序列最大值是哪个函数？怎么用？](#stl算法中查找序列最大值是哪个函数怎么用)
  - [STL算法中怎么给序列排正（倒）序？](#stl算法中怎么给序列排正倒序)
  - [](#)
  - [](#-1)
  - [](#-2)

# 第十章 泛型算法

## 1. 泛型算法的“泛型”指的是什么？

&emsp;&emsp; 标准库容器都有一组自己的操作，但标准库并没有给每个容器都定义成员函数来实现这些操作，而是提供了一组泛型（通用）的算法，这指的是它们可以用于不同类型的元素和多种容器类型。

## STL中的string容器的查找有几种？

&emsp;&emsp;有两种，一种是成员函数find()，还有一种是泛型算法中的find：

```cpp
// 第一种：algorithm中的find()函数：
//    参数  ：前两个参数为两个迭代器，表示搜索范围； 第三个参数为想搜索的字符串；
//    返回值：若找到了则返回目标元素的下标，找不到时返回为迭代器结尾；
string = "hello";
find(s.begin(), s.end(), 'o') == s.end()

// 第二种：string容器中的find()函数，有一组重载的版本：
string str1, str2;
char c;
str1.find(str2);        //从串str1中查找时str2，返回str2中首个字符在str1中的地址
str1.find(str2,5);      //从str1的第5个字符开始查找str2
str1.find(c);           //在str1中查找字符o并返回第一个查找到的地址
str1.find("str2",2 , 2);//从str1中的第二个字符开始查找of big的前两个字符
```

## c++模板元编程和泛型编程是一个概念吗 ？有何异同？
&emsp;&emsp;元编程侧重点在于用代码生成代码， 泛型编程侧重点在于「减小代码对特定数据类型的依赖」。

## STL算法中的求和函数是哪个？怎么用？
&emsp;&emsp;可以用accumulate函数，它带有三个形参：头两个形参指定要累加的元素范围，第三个形参则是累加的初值：
```cpp
vector<int>vec{[3,1,2,10,1]};
int sum = accumulate(vec.begin() , vec.end() , 10); // 结果为 27
int sum = accumulate(vec.begin() , vec.end() , 0);  // 结果为 17
```

## STL算法中查找序列最大值是哪个函数？怎么用？
```cpp
int max= max_element(c.begin(),c.end());// 值得注意的是，max_element()返回的是迭代器，所以需要解引用。
```

## STL算法中怎么给序列排正（倒）序？
```cpp
vector<int>vec{2,4,1,23,5,76,0,43,24,65};
// 一、排正序：
// sort()函数默认使用 元素类型的 <运算符 来实现排序:
sort(vec.begin(), vec.end();

// 二、排倒序：
// 方法1：传一个方向迭代器进去
sort(vec.rbegin(), vec.rend());
//// 方法2：也可以自己定义比较规则，然后作为sort()的第3个参数传进去：

// comparison function to be used to sort by word length
bool isShorter(const string &s1, const string &s2)C++ Primer, Fifth Edition{
    return s1.size() < s2.size();
}
// sort on word length, shortest to longest
sort(words.begin(), words.end(), isShorter);

bool smaller(int a, int b){
    return a > b;
}
sort(vec.begin(), vec.end(), smaller)
```

## 
&emsp;&emsp;

## 
&emsp;&emsp;

## 
&emsp;&emsp;

