- [第十章 泛型算法](#第十章-泛型算法)
  - [1. 泛型算法的“泛型”指的是什么？](#1-泛型算法的泛型指的是什么)
  - [有一些算法会操作两个序列，但是它们只接受一个迭代器来表示第二个序列，这应该注意什么？](#有一些算法会操作两个序列但是它们只接受一个迭代器来表示第二个序列这应该注意什么)
  - [使用那些会写容器元素的算法时需要注意什么？](#使用那些会写容器元素的算法时需要注意什么)
  - [如何确认一个容器中是否包含一个特定的值？](#如何确认一个容器中是否包含一个特定的值)
  - [如何在指定区间查找？](#如何在指定区间查找)
  - [STL中的string容器的查找有几种？](#stl中的string容器的查找有几种)
  - [c++模板元编程和泛型编程是一个概念吗 ？有何异同？](#c模板元编程和泛型编程是一个概念吗-有何异同)
  - [STL算法中的求和函数是哪个？怎么用？](#stl算法中的求和函数是哪个怎么用)
  - [accumulate()对第三个参数有何要求？](#accumulate对第三个参数有何要求)
  - [accumulate()怎么连接字符串？原理是？](#accumulate怎么连接字符串原理是)
      - [accumulate()连接字符串代码：](#accumulate连接字符串代码)
      - [accumulate()连接字符串原理](#accumulate连接字符串原理)
  - [TODO: accumulate()源码](#todo-accumulate源码)
  - [equal()函数](#equal函数)
      - [(1) equal()的函数原型是怎样的？](#1-equal的函数原型是怎样的)
      - [(2) equal()函数 的原理是？](#2-equal函数-的原理是)
      - [(3) 使用equal()时需要注意什么？](#3-使用equal时需要注意什么)
  - [fill()算法怎么用？](#fill算法怎么用)
  - [STL算法中查找序列最大值是哪个函数？怎么用？](#stl算法中查找序列最大值是哪个函数怎么用)
  - [STL算法中怎么给序列排正（倒）序？](#stl算法中怎么给序列排正倒序)
  - [](#)
  - [](#-1)
  - [](#-2)

# 第十章 泛型算法

## 1. 泛型算法的“泛型”指的是什么？
&emsp;&emsp; 标准库容器都有一组自己的操作，但标准库并没有给每个容器都定义成员函数来实现这些操作，而是提供了一组泛型（通用）的算法，这指的是它们可以用于不同类型的元素和多种容器类型。
&emsp;&emsp; 就拿find()来说，因为find()操作的是迭代器，也就是说find()函数不依赖于容器的类型


&emsp;
## 有一些算法会操作两个序列，但是它们只接受一个迭代器来表示第二个序列，这应该注意什么？
那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。


&emsp;
## 使用那些会写容器元素的算法时需要注意什么？
需要确保原序列大小 不小于 我们要求算法写入 的元素数目，也就是说要保证传递一个有效的区间给算法。


## 如何确认一个容器中是否包含一个特定的值？
用find()函数：
&emsp;&emsp;形参  ：前两个为迭代器，用来表示查找区间；第三个为 目标值；
&emsp;&emsp;返回值：找到时发挥指向该值的迭代器，没找到则返回尾后迭代器。
```cpp
string val = "a value for searching.";
list<string>lst = {'a', 'c','d'};
string::iterator result1 = find(val.cbegin(), val.cend()), 'a');
list<string>::iterator result2 = find(lst.cbegin(), lst.cend()), 'b');
```
我们甚至还可以在内置数组中使用find()，因为在内置数组中，指针类似于迭代器：
```cpp
int ia[] = {27, 210, 12, 47, 109, 83};
int val = 83;
// begin()和end()是标准库函数，在C++11中被引进，与顺序容器里面的同名函数功能一样；
int* result3 = find(begin(ia), end(val));
```

## 如何在指定区间查找？
&emsp;&emsp;
```cpp
list<int>lst = {1,2,3,4,5,6,7,8,9};
list<int>::iterator result4 = find(lst.cbegin(), lst.cend()) + 4, 9);
```

## STL中的string容器的查找有几种？
&emsp;&emsp;有两种，一种是成员函数find()，还有一种是泛型算法中的find：
```cpp
// 第一种：algorithm中的find()函数：
//    参数  ：前两个参数为两个迭代器，表示搜索范围； 第三个参数为想搜索的字符串；
//    返回值：若找到了则返回指向该元素的迭代器，找不到时返回为迭代器结尾；
string = "hello";
string::iterator result = find(s.begin(), s.end(), 'o') == s.end()

// 第二种：string容器中的find()函数，有一组重载的版本：
//    若存在则返回指定字符串出现的下标，若不存在则返回npose
string str1, str2;
char c;
string::size_type pos1 str1.find(str2);        //从串str1中查找时str2，返回str2中首个字符在str1中的地址
string::size_type pos2 str1.find(str2,5);      //从str1的第5个字符开始查找str2
string::size_type pos3 str1.find(c);           //在str1中查找字符o并返回第一个查找到的地址
string::size_type pos4 str1.find("str2",2 , 2);//从str1中的第二个字符开始查找of big的前两个字符
```

## c++模板元编程和泛型编程是一个概念吗 ？有何异同？
&emsp;&emsp;元编程侧重点在于用代码生成代码， 泛型编程侧重点在于「减小代码对特定数据类型的依赖」。

## STL算法中的求和函数是哪个？怎么用？
&emsp;&emsp;可以用accumulate()函数，它带有三个形参：头两个形参指定要累加的元素范围，第三个形参则是累加的初值：
```cpp
vector<int>vec{[3,1,2,10,1]};
int sum = accumulate(vec.begin() , vec.end() , 10); // 结果为 27
int sum = accumulate(vec.begin() , vec.end() , 0);  // 结果为 17
```
**注意：**accumulate()的第三个形参除了指定和的初值之外，还决定了①使用哪个加法运算符 ②返回值的类型

## accumulate()对第三个参数有何要求？
&emsp;&emsp;容器内元素的类型 必须和 第三个参数的类型 相匹配，或者可以转换为第三个参数的类型，若第三个参数为double，那元素的类型可以是 int、long long

## accumulate()怎么连接字符串？原理是？
#### accumulate()连接字符串代码：
```cpp
vector<string>v{"Hello", " ", "world", "!"};
// 输出：Hello world!
string sum1 = accumulate(v.cbegin(), v.cend(), string(""));
// 错误，""是const char*类型，这个类型没有定义+运算符
string sum2 = accumulate(v.cbegin(), v.cend(), "");// 应该像前面一样先把""转为string类型
```
#### accumulate()连接字符串原理
&emsp;&emsp;accumulate()调用的是 第三个参数的+运算符，而string定义了+运算符，所以可以这么操作。
&emsp;&emsp;也就是说，只要 该类型定义了+运算符，就能用accumulate()进行累加操作。


## TODO: accumulate()源码
```cpp
//版本1
template <typename InputIterator, typename T>
T accumulate(InputIterator first, InputIterator last, T init) {
	for ( ; first != last; ++first)
		init = init + *first;
	return init;
}

//版本2
template <typename InpurIterator, typename T, typename BinaryOperation>
T accumulate(InputIterator first, InputIterator last, T init, BinaryOperation binary_op) {
	for ( ; first != last; ++first)
		init = binary_op(init, *first);
	return init;
}
```
&emsp;


## equal()函数
#### (1) equal()的函数原型是怎样的？
```cpp
// 版本一：
template<class InputIterator1, class InputIterator2>
bool equal(InputIterator1 _First1, InputIterator1 _Last1, InputIterator2 _First2);
// 版本二：TODO: 讲解一下最后一个参数的意义
template<class InputIterator1, class InputIterator2, class BinaryPredicate>
bool equal(InputIterator1 _First1, InputIterator1 _Last1, InputIterator2 _First2, BinaryPredicate _Comp);
```
#### (2) equal()函数 的原理是？
&emsp;&emsp;和其它泛型算法一样，equal()函数使用的是迭代器来完成操作，所以我们可以使用equal()来比较两个不同类型的容器中的元素，甚至元素的类型也可以不一样（比如一个为string，一个为const char*），只要可以使用 == 来比较两个元素即可：
```cpp
bool fun(int n,int m)
{
    return n * 2 == m;
}
 
int main()
{
    vector<int>v{ 1,2,3,4 };
    list<int>lst{ 1,2,3,4,5};
    cout << equal(v.begin(), v.end(), lst.begin()) << endl;                     // 结果：1
    cout << equal(v.begin(), v.end(), lst.begin(), fun) << endl;                // 结果：0

    vector<const char *>v_char{"Hello", "World"};
    vector<string>v_string{"Hello", "World"};
    cout << equal(v_char.begin(), v_char.end(), v_string.begin()) << endl;      // 结果：1

}
```
#### (3) 使用equal()时需要注意什么？
&emsp;&emsp;和其它只接受一个单一迭代器来表示第二个序列的算法一样，equal()也假定第二个序列至少与第一个序列一样长，因此在调用equal()时可以先对两个序列的大小进行比较，要不然容易发生越界操作。而且如果大小都不一样就没必要调用equal()了。


&emsp;
## fill()算法怎么用？
先接受两个迭代器表示输入区间，然后接受一个值作为第三个参数，fill()将该区间的元素都设为 第三个参数 的值。
```cpp
fill(vec.begin(), vec.end(), 0); // reset each element to 0

fill(vec.begin(), vec.begin() + vec.size()/2, 10);// set a subsequence of the container to 10
```


&emsp;
## STL算法中查找序列最大值是哪个函数？怎么用？
```cpp
int max= max_element(c.begin(),c.end());// 值得注意的是，max_element()返回的是迭代器，所以需要解引用。
```

## STL算法中怎么给序列排正（倒）序？
```cpp
vector<int>vec{2,4,1,23,5,76,0,43,24,65};
// 一、排正序：
// sort()函数默认使用 元素类型的 <运算符 来实现排序:
sort(vec.begin(), vec.end();

// 二、排倒序：
// 方法1：传一个方向迭代器进去
sort(vec.rbegin(), vec.rend());
// 方法2：也可以自己定义比较规则，然后作为sort()的第3个参数传进去：
// comparison function to be used to sort by word length
bool isShorter(const string &s1, const string &s2)C++ Primer, Fifth Edition{
    return s1.size() < s2.size();
}
// sort on word length, shortest to longest
sort(words.begin(), words.end(), isShorter);

bool smaller(int a, int b){
    return a > b;
}
sort(vec.begin(), vec.end(), smaller)
```

## 
&emsp;&emsp;

## 
&emsp;&emsp;

## 
&emsp;&emsp;

