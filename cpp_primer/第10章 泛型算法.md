- [第十章 泛型算法](#第十章-泛型算法)
  - [1. 泛型算法的“泛型”指的是什么？](#1-泛型算法的泛型指的是什么)
  - [c++模板元编程和泛型编程是一个概念吗 ？有何异同？](#c模板元编程和泛型编程是一个概念吗-有何异同)
  - [泛型算法的操作基于什么？](#泛型算法的操作基于什么)
  - [C++对 算法库 在容器上的操作 有何限制？](#c对-算法库-在容器上的操作-有何限制)
      - [如何绕过这个限制？](#如何绕过这个限制)
  - [为什么算法不能（直接）添加或删除元素？](#为什么算法不能直接添加或删除元素)
  - [谓词](#谓词)
      - [(1)谓词是什么？](#1谓词是什么)
      - [(2) 谓词有哪几类？](#2-谓词有哪几类)
      - [(3) 谓词的作用？](#3-谓词的作用)
  - [lambda表达式](#lambda表达式)
      - [(1)什么是lambda表达式？](#1什么是lambda表达式)
      - [(2)lambda表达式的作用？](#2lambda表达式的作用)
      - [(3)语法规则](#3语法规则)
      - [(4)语法分析](#4语法分析)
        - [① [捕获列表]](#①-捕获列表)
          - [捕获列表的 隐式捕获 和 显示捕获](#捕获列表的-隐式捕获-和-显示捕获)
        - [② (操作符重载函数参数)](#②-操作符重载函数参数)
        - [③ mutable 或 exception 声明](#③-mutable-或-exception-声明)
        - [④ -> 返回值类型](#④---返回值类型)
        - [⑤ {函数体}](#⑤-函数体)
      - [(5)如何调用？](#5如何调用)
      - [(6)为stable_sort()编写一个lambda表达式，完成按字符串的大小排正序](#6为stable_sort编写一个lambda表达式完成按字符串的大小排正序)
      - [(7)sz是一个表示大小的局部变量，用lambd表达式捕获它，并返回 字符串长度 比sz大 的第一个元素的位置](#7sz是一个表示大小的局部变量用lambd表达式捕获它并返回-字符串长度-比sz大-的第一个元素的位置)
      - [下面的代码的输出是什么？](#下面的代码的输出是什么)
        - [输出：](#输出)
        - [原因：](#原因)
      - [如果希望一部分变量采用值捕获，一部分采用引用捕获，应该怎么做？](#如果希望一部分变量采用值捕获一部分采用引用捕获应该怎么做)
      - [编写lambda表达式的时候应该遵守什么原则？](#编写lambda表达式的时候应该遵守什么原则)
      - [lambda表达式 和 mutable关键字](#lambda表达式-和-mutable关键字)
        - [在上面的代码中，为什么j的值为43，前面不是已经 将v1置为0了吗？](#在上面的代码中为什么j的值为43前面不是已经-将v1置为0了吗)
      - [既然编译器可以推断lambda表达式的返回值类型，那为什么还要自己指定返回值类型呢？](#既然编译器可以推断lambda表达式的返回值类型那为什么还要自己指定返回值类型呢)
      - [如何指定lambda表达式的返回值类型？](#如何指定lambda表达式的返回值类型)
      - [lambda表达式和普通函数的区别？](#lambda表达式和普通函数的区别)
  - [bind()函数](#bind函数)
      - [bind()函数的作用是什么？](#bind函数的作用是什么)
      - [适配器指的是啥？](#适配器指的是啥)
      - [bind()函数的一般形式是怎样的？](#bind函数的一般形式是怎样的)
      - [bind()函数中的_1、_2表示什么？](#bind函数中的_1_2表示什么)
      - [在什么情况下需要使用bind()函数？](#在什么情况下需要使用bind函数)
  - [什么是插入迭代器？](#什么是插入迭代器)
  - [有一些算法会操作两个序列，但是它们只接受一个迭代器来表示第二个序列，这应该注意什么？](#有一些算法会操作两个序列但是它们只接受一个迭代器来表示第二个序列这应该注意什么)
  - [使用那些会写容器元素的算法时需要注意什么？](#使用那些会写容器元素的算法时需要注意什么)
  - [如何确认一个容器中是否包含一个特定的值？](#如何确认一个容器中是否包含一个特定的值)
  - [find_if()](#find_if)
  - [如何在指定区间查找？](#如何在指定区间查找)
  - [STL中的string容器的查找有几种？](#stl中的string容器的查找有几种)
  - [STL算法中的求和函数是哪个？怎么用？](#stl算法中的求和函数是哪个怎么用)
  - [accumulate()对第三个参数有何要求？](#accumulate对第三个参数有何要求)
  - [accumulate()怎么连接字符串？原理是？](#accumulate怎么连接字符串原理是)
      - [accumulate()连接字符串代码：](#accumulate连接字符串代码)
      - [accumulate()连接字符串原理](#accumulate连接字符串原理)
  - [accumulate()源码](#accumulate源码)
  - [equal()函数](#equal函数)
      - [(1) equal()的函数原型是怎样的？](#1-equal的函数原型是怎样的)
      - [(2) equal()函数 的原理是？](#2-equal函数-的原理是)
      - [(3) 使用equal()时需要注意什么？](#3-使用equal时需要注意什么)
  - [fill()算法怎么用？](#fill算法怎么用)
  - [string对象 与 char*对象 可以比较吗？](#string对象-与-char对象-可以比较吗)
  - [fill_n()](#fill_n)
      - [怎么用？](#怎么用)
      - [需要注意什么？](#需要注意什么)
      - [怎么避免误用？](#怎么避免误用)
  - [STL算法中查找序列最大值是哪个函数？怎么用？](#stl算法中查找序列最大值是哪个函数怎么用)
  - [sort()](#sort)
      - [sort()的原理是？](#sort的原理是)
      - [怎么给序列排正（倒）序？](#怎么给序列排正倒序)
      - [怎么给序列排倒序：](#怎么给序列排倒序)
  - [stable_sort()](#stable_sort)
      - [(1) stable_sort() 和 sort() 有何区别？](#1-stable_sort-和-sort-有何区别)
      - [(2) 为什么会有这样的区别？](#2-为什么会有这样的区别)
  - [copy()](#copy)
      - [(1)函数原型](#1函数原型)
      - [(2) 注意事项](#2-注意事项)
      - [(3) 内置数组的拷贝](#3-内置数组的拷贝)
      - [(4) 如何利用copy()将 一个vector的元素 复制(插入)到 另一个vector的 末尾？](#4-如何利用copy将-一个vector的元素-复制插入到-另一个vector的-末尾)
  - [replace() TODO:](#replace-todo)
  - [如何对一个vector进行去重？](#如何对一个vector进行去重)
  - [for_each算法 TODO:](#for_each算法-todo)
  - [](#)
      - [(1)](#1)
      - [(2)](#2)
      - [(3)](#3)
      - [(4)](#4)
      - [(5)](#5)
      - [(6)](#6)

# 第十章 泛型算法

## 1. 泛型算法的“泛型”指的是什么？
&emsp;&emsp; 标准库容器都有一组自己的操作，但标准库并没有给每个容器都定义成员函数来实现这些操作，而是提供了一组泛型（通用）的算法，这指的是它们可以用于不同类型的元素和多种容器类型。
&emsp;&emsp; 就拿find()来说，因为find()操作的是迭代器，也就是说find()函数不依赖于容器的类型



## c++模板元编程和泛型编程是一个概念吗 ？有何异同？
&emsp;&emsp;元编程侧重点在于用代码生成代码， 泛型编程侧重点在于「减小代码对特定数据类型的依赖」。



## 泛型算法的操作基于什么？
&emsp;&emsp;这里的泛型(generic)指的就是”通用“的意思，为了实现”通用“这一特性，每个泛型算法的实现都独立于单独的容器，并且不依赖于容器存储的元素类型，迭代器将算法和容器绑定起来。算法基于迭代器及其操作实现，而并非基于容器操作。



## C++对 算法库 在容器上的操作 有何限制？
&emsp;&emsp;算法可能改变，但算法决不修改容器的大小（不插入、不删除）
#### 如何绕过这个限制？
&emsp;&emsp;用插入迭代器



&emsp;
## 为什么算法不能（直接）添加或删除元素？
&emsp;&emsp;因为算法是对迭代器进行操作的，而增加（删除）元素会造成迭代器失效，所以不能。



&emsp;
## 谓词
#### (1)谓词是什么？
&emsp;&emsp; **谓词(predicate)** 是一个可调用的表达式，其 **返回结果** 是一个能作为条件的值。
#### (2) 谓词有哪几类？
&emsp;&emsp; 两类，分别是 **一元谓词(unary predicate)** 和 **二元谓词(binary predicate)**。所谓一元、二元指的是它们接受节参数：一元谓词接受一个参数，二元谓词接受两个参数。
#### (3) 谓词的作用？
&emsp;&emsp;很多算法都会比较输入序列中的元素，默认情况下，这些算法都会调用 元素类型的“<”或“==”来完成比较，但有的时候我们希望可以定义自己的比较规则，而这可以通过谓词来完成。
&emsp;&emsp;拿sort()函数来说，他有一个重载的函数，这个函数接受第三个参数，这个参数就是一个二元谓词，这个谓词会代替“<”进行比较，然后返回一个比较结果，sort()会根据这个比较结果进行排序，具体可以看后面关于sort()函数的笔记。



&emsp;
## lambda表达式
#### (1)什么是lambda表达式？
&emsp;&emsp;
#### (2)lambda表达式的作用？
&emsp;&emsp;
#### (3)语法规则
```cpp
[捕获列表] (操作符重载函数参数) mutable 或 exception 声明 -> 返回值类型 {函数体}
```
① 可以忽略括号和参数列表，此时相当于指定一个空参数列表；
② 
#### (4)语法分析
##### ① [捕获列表] 
&emsp;&emsp;这部分标识一个 Lambda 表达式的开始，这部分必须存在，不能省略！
###### 捕获列表的 隐式捕获 和 显示捕获
&emsp;&emsp;显示捕获：[&str]、[str]
&emsp;&emsp;隐式捕获：[&]、[=]
&emsp;&emsp;捕获列表是传递给编译器自动生成的函数对象类的构造函数的。捕获列表只能使用那些到定义 Lambda 为止时 Lambda 所在作用范围内可见的非static局部变量(包括 Lambda 所在类的 this),**非static局部变量，如：静态变量(包括局部静态变量)、全局变量等可以不经捕获，直接使用**。
**也就是说，捕获列表是用来捕获局部变量的**，捕获列表有以下形式：

形式|解释
---|--|
空|没有任何捕获列表。
=|隐式捕获，函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的 this），并且是值传递方式（相当于编译器自动为我们按值传递了所有局部变量）。
&|隐式捕获，函数体内可以使用 Lambda 所在范围内所有可见的局部变量（包括 Lambda 所在类的 this），并且是引用传递方式（相当于是编译器自动为我们按引用传递了所有局部变量）。
this|函数体内可以使用 Lambda 所在类中的成员变量。
a|。将 a 按值进行传递。按值进行传递时，函数体内不能修改传递进来的 a 的拷贝，因为默认情况下函数是 const 的，要修改传递进来的拷贝，可以添加 mutable 修饰符。
&a|将 a 按引用进行传递。
a,&b|将 a 按值传递，b 按引用进行传递。
=,&a,&b|。除 a 和 b 按引用进行传递外，其他参数都按值进行传递。
&,a,b|除 a 和 b 按值进行传递外，其他参数都按引用进行传递。
##### ② (操作符重载函数参数)
&emsp;&emsp;标识重载的 () 操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如: (a, b)）和按引用 (如: (&a, &b)) 两种方式进行传递。
##### ③ mutable 或 exception 声明
&emsp;&emsp;这部分可以省略。按值传递捕获列表时，加上 mutable 修饰符后，可以修改传递进来的拷贝（注意是能修改拷贝，而不是值本身）。exception 声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用 throw(int)。
##### ④ -> 返回值类型
&emsp;&emsp;可以忽略返回类型，lambda会根据函数体中的代码推断出返回类型，如果只有一个return语句的话，则从返回的值推断返回类型，否则返回void类型；
##### ⑤ {函数体}
&emsp;&emsp;标识函数的实现，这部分不能省略，但函数体可以为空。
#### (5)如何调用？
&emsp;&emsp;和普通函数一样，也是使用 调用运算符：
```cpp
auto f = [] { return 42; }; //不接受参数，返回42
auto j = f();
cout << j << endl;        // prints 42
```
#### (6)为stable_sort()编写一个lambda表达式，完成按字符串的大小排正序
```cpp
// 将lambda表达式作为第三个参数传进去就行了
stable_sort(words.begin(), words.end(), [](const string &a, const string &b){return a.size() < b.size();});
```
#### (7)sz是一个表示大小的局部变量，用lambd表达式捕获它，并返回 字符串长度 比sz大 的第一个元素的位置
```cpp
vector<string>::size_type sz;
// get an iterator to the first element whose size() is >= sz
auto wc = find_if(words.begin(), words.end(),
                    [sz](const string &a)
                        { return a.size() >= sz; });
```
#### 下面的代码的输出是什么？
```cpp
int main()
{
    int j = 1;
    auto by_val_lambda = [=]{ return j + 1; }; // 捕获列表里的“=”表示捕获当前作用域的所有局部变量，并按 值传递
    auto by_ref_lambda = [&]{ return j + 1; }; // 捕获列表里的“&”表示捕获当前作用域的所有局部变量，并按 引用传递
    auto print = [=]{
        cout << "print by val lambda: " << by_val_lambda() << ", ";
        cout << "print by ref lambda: " << by_ref_lambda() << endl;
    };

    print();

    j += 10; 
    print();

    return 0;
}
```
##### 输出：
```cpp
print by val lambda: 2
print by ref lambda: 2
print by val lambda: 2
print by ref lambda: 12
```
##### 原因：
&emsp;&emsp;by_val_lambda 是通过值传递捕捉的变量 j，所以这个变量在其内部的值永远是 1，所以不论何时调用这个函数都会返回 2。
&emsp;&emsp;而 by_ref_lambda 是通过引用传递捕捉的变量 j，所以内部的值会随着外部的使用而发生变化，所以在 j += 10 之后，显然会返回 12。
#### 如果希望一部分变量采用值捕获，一部分采用引用捕获，应该怎么做？
混用隐式捕获 和 显示捕获的时候，必须注意下面几点：
&emsp;&emsp;① 捕获列表第一个必须是 & 或 =
&emsp;&emsp;② 显示捕获的变量必须使用与隐式捕获不同的方式，即 [&， &str]是不合法的。
```cpp
void func(vector<string> &words, vector<string>::size_type sz, ostream &os=cout, string str="")
{
    // os按隐式捕获（即引用捕获），str按值捕获。
    for_each(words.begin(), words.end(), [&, str](const string &s){os << s << endl;});

}
```
#### 编写lambda表达式的时候应该遵守什么原则？
&emsp;&emsp;在捕获一个指针、迭代器 或者 按引用捕获 时，确保在lambda表达式执行的时候绑定到迭代器、指针或者引用的对象还存在。
&emsp;&emsp;一般来说，应该尽量减少捕获的数据量，来避免潜在的捕获导致的问题，而且如果可能的话，尽量避免捕获指针或引用。
&emsp;&emsp;对于那种只在一两个地方使用的简单操作，lambda表达式是最好用的。如果我们需要在很多地方使用相同的操作，通常应该定义一个函数，而不是多次编写相同的lambda表达式
#### lambda表达式 和 mutable关键字
对于一个**被值捕获**的变量，lambda表达式如果尝试改变它的值，则会报错：
```cpp
void fcn3()
{
    size_t v1 = 42; 
    auto f = [v1] () { return ++v1; };
    v1 = 0;
    auto j = f(); 
}

上面的代码报错如下：
    test.cpp: In lambda function:
    test.cpp:10:33: error: increment of read-only variable ‘v1’
        auto f = [v1] () { return ++v1; };
                                    ^
```
在lambda表达式中添加mutable关键字后顺利通过编译：
```cpp
void fcn3()
{
    size_t v1 = 42; // local variable
    auto f = [v1] () mutable { return ++v1; }; // 添加了 mutable，下载可以改变值传递的变量了
    v1 = 0;
    auto j = f(); 
    cout << j << endl; // j is 43
}
```
##### 在上面的代码中，为什么j的值为43，前面不是已经 将v1置为0了吗？
&emsp;&emsp;因为v1是值传递的，f在捕获v1的时候是42，到了后面即使执行了 v1 = 0，也对它没影响，如果想通过改变v1的值来影响lambda表达式的话，需要用 引用捕获：
```cpp
void fcn4()
{
    size_t v1 = 42; // local variable
    auto f2 = [&v1] { return ++v1; }; // 这里v1是 引用捕获
    v1 = 0;         // 会影响lambda表达式
    auto j = f2();  
    cout << j << endl; // j is 1
}
```
#### 既然编译器可以推断lambda表达式的返回值类型，那为什么还要自己指定返回值类型呢？
&emsp;&emsp;默认情况下，如果一个 lambda体内包含 return之外的任何语句，则编译器会假定此lambda返回void，和函数一样，被编译器推断为void的lambda表达式不允许返回值。
下面的代码的本意是 将序列vi的所有负数替换为其绝对值：
```cpp
// 错误: 编译器推断出下面的lambda表达式返回void，但它返回了一个int值
transform(vi.begin(), vi.end(), vi.begin(),
			[](int i) 
			{ if (i < 0) return -i; else return i;
});
```
#### 如何指定lambda表达式的返回值类型？
对于上面transform()函数的调用，应该像下面这样指定返回值类型：
```cpp
transform(vi.begin(), vi.end(), vi.begin(), 
			[](int i) -> int 
			{ if (i < 0) return -i; else return i; });
```
#### lambda表达式和普通函数的区别？



&emsp;
## bind()函数
#### bind()函数的作用是什么？
&emsp;&emsp;bind()函数相当于一个函数适配器，主要是进行参数绑定。
#### 适配器指的是啥？
&emsp;&emsp;现在MacBook已经不带usb接口了，如果你想用usb接口的u盘插到MacBook上，那你就要用一个合适的转接头才行，这个转接头就是一个适配器。
#### bind()函数的一般形式是怎样的？
```cpp
auto newCallable = bind(callable, arg_list)
```
&emsp;&emsp;**newCallable**本身是一个可调用的对象；
&emsp;&emsp;**arg_list**是一个逗号分隔的参数列表，对应给定的callable的参数。即，当我们调用newCallable时，newCallable会调用callable，并传给它 arg_list中的参数。
#### bind()函数中的_1、_2表示什么？
&emsp;&emsp;**arg_list中可能包含形如_n的名字**，其中n是一个整数，这些参数是“占位符”，表示newCallable的参数，它们占据了传递给newCallable的参数的“位置”。数值n表示生成的可调用对象中参数的位置：_1表为newCallable的第一个参数， _2为第二个参数？
#### 在什么情况下需要使用bind()函数？
&emsp;&emsp;对于那种只在一两个地方使用的简单操作，lambda表达式是最好用的。如果我们需要在很多地方使用相同的操作，通常应该定义一个函数，而不是多次编写相同的lambda表达式，例如我们用find_f()调用lambda比较一个string和一个给定大小：
```cpp
find_if(words.begin(),words.end(),[sz](const string &a){return a.size()>= sz;}); 
```
我们可以很容易的编写一个完成同样工作的函数check_size()：
```cpp
bool check_size(const string &s, string::size_type sz)
{
    return s.size() >= sz;
}
```
但是，我们不能用这个函数作为find_if()的一个参数，**因为find_if()接受的是是一个一元谓词**，此时可以考虑bind函数，使用bind，我们可以将原来基于lambda的find_if()调用：
```cpp
auto wc = find_if(words.begin(),words.end(),bind(check_size,_1,sz));
```



&emsp;
## 什么是插入迭代器？
&emsp;&emsp; TODO:  



&emsp;
## 有一些算法会操作两个序列，但是它们只接受一个迭代器来表示第二个序列，这应该注意什么？
那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。



&emsp;
## 使用那些会写容器元素的算法时需要注意什么？
需要确保原序列大小 不小于 我们要求算法写入 的元素数目，也就是说要保证传递一个有效的区间给算法。



&emsp;
## 如何确认一个容器中是否包含一个特定的值？
用find()函数：
&emsp;&emsp;形参  ：前两个为迭代器，用来表示查找区间；第三个为 目标值；
&emsp;&emsp;返回值：找到时发挥指向该值的迭代器，没找到则返回尾后迭代器。
```cpp
string val = "a value for searching.";
list<string>lst = {'a', 'c','d'};
string::iterator result1 = find(val.cbegin(), val.cend()), 'a');
list<string>::iterator result2 = find(lst.cbegin(), lst.cend()), 'b');
```
我们甚至还可以在内置数组中使用find()，因为在内置数组中，指针类似于迭代器：
```cpp
int ia[] = {27, 210, 12, 47, 109, 83};
int val = 83;
// begin()和end()是标准库函数，在C++11中被引进，与顺序容器里面的同名函数功能一样；
int* result3 = find(begin(ia), end(val));
```



&emsp;
## find_if() 



&emsp;
## 如何在指定区间查找？
&emsp;&emsp;
```cpp
list<int>lst = {1,2,3,4,5,6,7,8,9};
list<int>::iterator result4 = find(lst.cbegin(), lst.cend()) + 4, 9);
```



&emsp;
## STL中的string容器的查找有几种？
&emsp;&emsp;有两种，一种是成员函数find()，还有一种是泛型算法中的find：
```cpp
// 第一种：algorithm中的find()函数：
//    参数  ：前两个参数为两个迭代器，表示搜索范围； 第三个参数为想搜索的字符串；
//    返回值：若找到了则返回指向该元素的迭代器，找不到时返回为迭代器结尾；
string = "hello";
string::iterator result = find(s.begin(), s.end(), 'o') == s.end()

// 第二种：string容器中的find()函数，有一组重载的版本：
//    若存在则返回指定字符串出现的下标，若不存在则返回npose
string str1, str2;
char c;
string::size_type pos1 str1.find(str2);        //从串str1中查找时str2，返回str2中首个字符在str1中的地址
string::size_type pos2 str1.find(str2,5);      //从str1的第5个字符开始查找str2
string::size_type pos3 str1.find(c);           //在str1中查找字符o并返回第一个查找到的地址
string::size_type pos4 str1.find("str2",2 , 2);//从str1中的第二个字符开始查找of big的前两个字符
```



&emsp;
## STL算法中的求和函数是哪个？怎么用？
&emsp;&emsp;可以用accumulate()函数，它带有三个形参：头两个形参指定要累加的元素范围，第三个形参则是累加的初值：
```cpp
vector<int>vec{[3,1,2,10,1]};
int sum = accumulate(vec.begin() , vec.end() , 10); // 结果为 27
int sum = accumulate(vec.begin() , vec.end() , 0);  // 结果为 17
```
**注意：**accumulate()的第三个形参除了指定和的初值之外，还决定了①使用哪个加法运算符 ②返回值的类型



&emsp;
## accumulate()对第三个参数有何要求？
&emsp;&emsp;容器内元素的类型 必须和 第三个参数的类型 相匹配，或者可以转换为第三个参数的类型，若第三个参数为double，那元素的类型可以是 int、long long



&emsp;
## accumulate()怎么连接字符串？原理是？
#### accumulate()连接字符串代码：
```cpp
vector<string>v{"Hello", " ", "world", "!"};
// 输出：Hello world!
string sum1 = accumulate(v.cbegin(), v.cend(), string(""));
// 错误，""是const char*类型，这个类型没有定义+运算符
string sum2 = accumulate(v.cbegin(), v.cend(), "");// 应该像前面一样先把""转为string类型
```
#### accumulate()连接字符串原理
&emsp;&emsp;accumulate()调用的是 第三个参数的+运算符，而string定义了+运算符，所以可以这么操作。
&emsp;&emsp;也就是说，只要 该类型定义了+运算符，就能用accumulate()进行累加操作。



&emsp;
## accumulate()源码
```cpp
//版本1
template <typename InputIterator, typename T>
T accumulate(InputIterator first, InputIterator last, T init) {
	for ( ; first != last; ++first)
		init = init + *first;
	return init;
}

//版本2
template <typename InpurIterator, typename T, typename BinaryOperation>
T accumulate(InputIterator first, InputIterator last, T init, BinaryOperation binary_op) {
	for ( ; first != last; ++first)
		init = binary_op(init, *first);
	return init;
}
```



&emsp;
## equal()函数
#### (1) equal()的函数原型是怎样的？
```cpp
// 版本一：
template<class InputIterator1, class InputIterator2>
bool equal(InputIterator1 _First1, InputIterator1 _Last1, InputIterator2 _First2);
// 版本二：TODO: 讲解一下最后一个参数的意义
template<class InputIterator1, class InputIterator2, class BinaryPredicate>
bool equal(InputIterator1 _First1, InputIterator1 _Last1, InputIterator2 _First2, BinaryPredicate _Comp);
```
#### (2) equal()函数 的原理是？
&emsp;&emsp;和其它泛型算法一样，equal()函数使用的是迭代器来完成操作，所以我们可以使用equal()来比较两个不同类型的容器中的元素，甚至元素的类型也可以不一样（比如一个为string，一个为const char*），只要可以使用 == 来比较两个元素即可：
```cpp
bool fun(int n,int m)
{
    return n * 2 == m;
}
 
int main()
{
    vector<int>v{ 1,2,3,4 };
    list<int>lst{ 1,2,3,4,5};
    cout << equal(v.begin(), v.end(), lst.begin()) << endl;                     // 结果：1
    cout << equal(v.begin(), v.end(), lst.begin(), fun) << endl;                // 结果：0

    vector<const char *>v_char{"Hello", "World"};
    vector<string>v_string{"Hello", "World"};
    cout << equal(v_char.begin(), v_char.end(), v_string.begin()) << endl;      // 结果：1

}
```
#### (3) 使用equal()时需要注意什么？
&emsp;&emsp;和其它只接受一个单一迭代器来表示第二个序列的算法一样，equal()也假定第二个序列至少与第一个序列一样长，因此在调用equal()时可以先对两个序列的大小进行比较，要不然容易发生越界操作。而且如果大小都不一样就没必要调用equal()了。



&emsp;
## fill()算法怎么用？
先接受两个迭代器表示输入区间，然后接受一个值作为第三个参数，fill()将该区间的元素都设为 第三个参数 的值。
```cpp
fill(vec.begin(), vec.end(), 0); // reset each element to 0
fill(vec.begin(), vec.begin() + vec.size()/2, 10);// set a subsequence of the container to 10
```



&emsp;
## string对象 与 char*对象 可以比较吗？
&emsp;&emsp;可以的，String标准库为string对象与char *对象定义了相等（＝＝）操作符



&emsp;
## fill_n()
#### 怎么用？
```cpp
vector<int> vec; 
fill_n(vec.begin(), vec.size(), 0); // 将所有元素都设为0
```
#### 需要注意什么？
&emsp;&emsp;和其它向目的位置写入数据的算法一样，fill_n假定目的位置足够大，能容纳要写入的元素，因此我们在使用fill_n()时需要确保目标容器有足够的空间
&emsp;&emsp;下面是一个错误的用法：
```cpp
vector<int> vec;             // empty vector
fill_n(vec.begin(), 10, 0);  // disaster: attempts to write to ten (nonexistent) elements in vec
```
#### 怎么避免误用？
&emsp;&emsp;配合插入迭代器(insert iterator)使用即可：
```cpp
vector<int> vec; // empty vector
// 正确: 虽然vec是空容器，但是插入迭代器会调用push_back()在vec后面插入元素
fill_n(back_inserter(vec), 10, 0); // appends ten elements to vec
```



&emsp;
## STL算法中查找序列最大值是哪个函数？怎么用？
```cpp
int max= max_element(c.begin(),c.end());// 值得注意的是，max_element()返回的是迭代器，所以需要解引用。
```



&emsp;
## sort()
#### sort()的原理是？
&emsp;&emsp;sort()算法默认调用元素类型的"<"来进行比较，根据比较结果进行排序。
#### 怎么给序列排正（倒）序？
```cpp
vector<int>vec{2,4,1,23,5,76,0,43,24,65};
// sort()函数默认使用 元素类型的 <运算符 来实现排序:
sort(vec.begin(), vec.end();
```
#### 怎么给序列排倒序：
```cpp
// 方法1：传一个方向迭代器进去
sort(vec.rbegin(), vec.rend());
// 方法2：也可以自己定义比较规则，然后作为sort()的第3个参数传进去：
// comparison function to be used to sort by word length
bool isShorter(const string &s1, const string &s2)C++ Primer, Fifth Edition{
    return s1.size() < s2.size();
}
// sort on word length, shortest to longest
sort(words.begin(), words.end(), isShorter);

bool smaller(int a, int b){
    return a > b;
}
sort(vec.begin(), vec.end(), smaller)
```



&emsp;
## stable_sort()
#### (1) stable_sort() 和 sort() 有何区别？
&emsp;&emsp;带有stable的函数可保证相等元素的原本相对次序在排序后保持不变。或许你会问，既然相等，你还管他相对位置呢，也分不清 楚谁是谁了？这里需要弄清楚一个问题，这里的相等，是指你提供的函数表示两个元素相等，并不一定是一摸一样的元素,比如对于如下的比较函数，
```cpp
bool isShorter(const string &str1, const string &str2)
{
    return str1.length() < str2.length();
}

stable_sort(vec1.begin(), vec1.end(), isShorter);//
sort(vec2.begin(), vec2.end(), isShorter);
```
对于上面的比较函数isShorter()，"apples" 和 "winter" 就是相等的，如果在"apples" 出现在"winter"前面，用带stable的函数排序后，他们的次序**一定不变** ，如果你使用的是不带"stable"的函数排序，那么排序完 后，"winter"**有可能**在"apples"的前面。
#### (2) 为什么会有这样的区别？
TODO: 一个是归并一个是快排？



&emsp;
## copy()
#### (1)函数原型
```cpp
template<class InputIterator, class OutputIterator>  
       OutputIterator copy(  
          InputIterator _First,   
          InputIterator _Last,   
          OutputIterator _DestBeg  
       );
```
#### (2) 注意事项
&emsp;&emsp;和其它接受三个迭代器的算法一样，我们需要保证目的序列的大小不小于输入序列。
#### (3) 内置数组的拷贝
```cpp
int a1[] = {0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1) / sizeof(*a1)]; // 保证a1和a2大小一致
auto ret = copy(begin(a1), end(a1), a2) // 成功的话，ret将是a1的尾后迭代器的位置
```
#### (4) 如何利用copy()将 一个vector的元素 复制(插入)到 另一个vector的 末尾？
利用 尾后插入迭代器 即可：
```cpp
vector<int> src = { 0, 1, 2, 3, 4 };
vector<int> dst = { -10, -9 };
auto ret = copy(src.begin(), src.end(), back_inserter(dst));
```



&emsp;
## replace() TODO:
&emsp;&emsp;



&emsp;
## 如何对一个vector进行去重？
```cpp
vector<string>vec{the, quick, red, fox, jumps, over, the, slow, red, turtle};
void elimDups(vector<string> &words)
{
    // 先排序，方便找到重复单词
    sort(words.begin(), words.end());
    // unique 重排输入范围，使得每个单词只出现一次
    // unique函数的返回值为 指向不重复区域之后一个位置的迭代器。
    auto end_unique = unique(words.begin(), words.end());
    // 因为泛型算法都不能改变容器大小，一次需要借助vector容器的erase()成员来完成删除操作
    words.erase(end_unique, words.end());
}
elimDups(vec);
```



emsp;
## for_each算法 TODO: 
&emsp;&emsp;













































&emsp;
## 
&emsp;&emsp;
#### (1)
```cpp

```
#### (2) 
&emsp;&emsp;
#### (3) 
&emsp;&emsp;
```cpp

```
#### (4) 
&emsp;&emsp;
```cpp

```
#### (5)
&emsp;&emsp;
```cpp

```
#### (6)
&emsp;&emsp;
```cpp

```