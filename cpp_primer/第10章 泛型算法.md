- [第十章 泛型算法](#第十章-泛型算法)
  - [1. 泛型算法的“泛型”指的是什么？](#1-泛型算法的泛型指的是什么)
  - [c++模板元编程和泛型编程是一个概念吗 ？有何异同？](#c模板元编程和泛型编程是一个概念吗-有何异同)
  - [泛型算法的操作基于什么？](#泛型算法的操作基于什么)
  - [C++对 算法库 在容器上的操作 有何限制？](#c对-算法库-在容器上的操作-有何限制)
      - [如何绕过这个限制？](#如何绕过这个限制)
  - [为什么算法不能（直接）添加或删除元素？](#为什么算法不能直接添加或删除元素)
  - [什么是插入迭代器？](#什么是插入迭代器)
  - [有一些算法会操作两个序列，但是它们只接受一个迭代器来表示第二个序列，这应该注意什么？](#有一些算法会操作两个序列但是它们只接受一个迭代器来表示第二个序列这应该注意什么)
  - [使用那些会写容器元素的算法时需要注意什么？](#使用那些会写容器元素的算法时需要注意什么)
  - [如何确认一个容器中是否包含一个特定的值？](#如何确认一个容器中是否包含一个特定的值)
  - [如何在指定区间查找？](#如何在指定区间查找)
  - [STL中的string容器的查找有几种？](#stl中的string容器的查找有几种)
  - [STL算法中的求和函数是哪个？怎么用？](#stl算法中的求和函数是哪个怎么用)
  - [accumulate()对第三个参数有何要求？](#accumulate对第三个参数有何要求)
  - [accumulate()怎么连接字符串？原理是？](#accumulate怎么连接字符串原理是)
      - [accumulate()连接字符串代码：](#accumulate连接字符串代码)
      - [accumulate()连接字符串原理](#accumulate连接字符串原理)
  - [accumulate()源码](#accumulate源码)
  - [equal()函数](#equal函数)
      - [(1) equal()的函数原型是怎样的？](#1-equal的函数原型是怎样的)
      - [(2) equal()函数 的原理是？](#2-equal函数-的原理是)
      - [(3) 使用equal()时需要注意什么？](#3-使用equal时需要注意什么)
  - [fill()算法怎么用？](#fill算法怎么用)
  - [string对象 与 char*对象 可以比较吗？](#string对象-与-char对象-可以比较吗)
  - [fill_n()](#fill_n)
      - [怎么用？](#怎么用)
      - [需要注意什么？](#需要注意什么)
      - [怎么避免误用？](#怎么避免误用)
  - [STL算法中查找序列最大值是哪个函数？怎么用？](#stl算法中查找序列最大值是哪个函数怎么用)
  - [sort()](#sort)
      - [sort()的原理是？](#sort的原理是)
      - [怎么给序列排正（倒）序？](#怎么给序列排正倒序)
      - [怎么给序列排倒序：](#怎么给序列排倒序)
  - [copy()](#copy)
      - [(1)函数原型](#1函数原型)
      - [(2) 注意事项](#2-注意事项)
      - [(3) 内置数组的拷贝](#3-内置数组的拷贝)
      - [(4) 如何利用copy()将 一个vector的元素 复制(插入)到 另一个vector的 末尾？](#4-如何利用copy将-一个vector的元素-复制插入到-另一个vector的-末尾)
  - [replace() TODO:](#replace-todo)
  - [如何对一个vector进行去重？](#如何对一个vector进行去重)
      - [(1)](#1)
  - [如何对一个vector进行去重？](#如何对一个vector进行去重-1)
      - [(1)](#1-1)
      - [(2)](#2)
      - [(3)](#3)
      - [(4)](#4)
      - [(5)](#5)
      - [(6)](#6)

# 第十章 泛型算法

## 1. 泛型算法的“泛型”指的是什么？
&emsp;&emsp; 标准库容器都有一组自己的操作，但标准库并没有给每个容器都定义成员函数来实现这些操作，而是提供了一组泛型（通用）的算法，这指的是它们可以用于不同类型的元素和多种容器类型。
&emsp;&emsp; 就拿find()来说，因为find()操作的是迭代器，也就是说find()函数不依赖于容器的类型



## c++模板元编程和泛型编程是一个概念吗 ？有何异同？
&emsp;&emsp;元编程侧重点在于用代码生成代码， 泛型编程侧重点在于「减小代码对特定数据类型的依赖」。



## 泛型算法的操作基于什么？
&emsp;&emsp;这里的泛型(generic)指的就是”通用“的意思，为了实现”通用“这一特性，每个泛型算法的实现都独立于单独的容器，并且不依赖于容器存储的元素类型，迭代器将算法和容器绑定起来。算法基于迭代器及其操作实现，而并非基于容器操作。



## C++对 算法库 在容器上的操作 有何限制？
&emsp;&emsp;算法可能改变，但算法决不修改容器的大小（不插入、不删除）
#### 如何绕过这个限制？
&emsp;&emsp;用插入迭代器



&emsp;
## 为什么算法不能（直接）添加或删除元素？
&emsp;&emsp;因为算法是对迭代器进行操作的，而增加（删除）元素会造成迭代器失效，所以不能。



&emsp;
## 什么是插入迭代器？
&emsp;&emsp;TODO: 



&emsp;
## 有一些算法会操作两个序列，但是它们只接受一个迭代器来表示第二个序列，这应该注意什么？
那些只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长。



&emsp;
## 使用那些会写容器元素的算法时需要注意什么？
需要确保原序列大小 不小于 我们要求算法写入 的元素数目，也就是说要保证传递一个有效的区间给算法。



&emsp;
## 如何确认一个容器中是否包含一个特定的值？
用find()函数：
&emsp;&emsp;形参  ：前两个为迭代器，用来表示查找区间；第三个为 目标值；
&emsp;&emsp;返回值：找到时发挥指向该值的迭代器，没找到则返回尾后迭代器。
```cpp
string val = "a value for searching.";
list<string>lst = {'a', 'c','d'};
string::iterator result1 = find(val.cbegin(), val.cend()), 'a');
list<string>::iterator result2 = find(lst.cbegin(), lst.cend()), 'b');
```
我们甚至还可以在内置数组中使用find()，因为在内置数组中，指针类似于迭代器：
```cpp
int ia[] = {27, 210, 12, 47, 109, 83};
int val = 83;
// begin()和end()是标准库函数，在C++11中被引进，与顺序容器里面的同名函数功能一样；
int* result3 = find(begin(ia), end(val));
```



&emsp;
## 如何在指定区间查找？
&emsp;&emsp;
```cpp
list<int>lst = {1,2,3,4,5,6,7,8,9};
list<int>::iterator result4 = find(lst.cbegin(), lst.cend()) + 4, 9);
```



&emsp;
## STL中的string容器的查找有几种？
&emsp;&emsp;有两种，一种是成员函数find()，还有一种是泛型算法中的find：
```cpp
// 第一种：algorithm中的find()函数：
//    参数  ：前两个参数为两个迭代器，表示搜索范围； 第三个参数为想搜索的字符串；
//    返回值：若找到了则返回指向该元素的迭代器，找不到时返回为迭代器结尾；
string = "hello";
string::iterator result = find(s.begin(), s.end(), 'o') == s.end()

// 第二种：string容器中的find()函数，有一组重载的版本：
//    若存在则返回指定字符串出现的下标，若不存在则返回npose
string str1, str2;
char c;
string::size_type pos1 str1.find(str2);        //从串str1中查找时str2，返回str2中首个字符在str1中的地址
string::size_type pos2 str1.find(str2,5);      //从str1的第5个字符开始查找str2
string::size_type pos3 str1.find(c);           //在str1中查找字符o并返回第一个查找到的地址
string::size_type pos4 str1.find("str2",2 , 2);//从str1中的第二个字符开始查找of big的前两个字符
```



&emsp;
## STL算法中的求和函数是哪个？怎么用？
&emsp;&emsp;可以用accumulate()函数，它带有三个形参：头两个形参指定要累加的元素范围，第三个形参则是累加的初值：
```cpp
vector<int>vec{[3,1,2,10,1]};
int sum = accumulate(vec.begin() , vec.end() , 10); // 结果为 27
int sum = accumulate(vec.begin() , vec.end() , 0);  // 结果为 17
```
**注意：**accumulate()的第三个形参除了指定和的初值之外，还决定了①使用哪个加法运算符 ②返回值的类型



&emsp;
## accumulate()对第三个参数有何要求？
&emsp;&emsp;容器内元素的类型 必须和 第三个参数的类型 相匹配，或者可以转换为第三个参数的类型，若第三个参数为double，那元素的类型可以是 int、long long



&emsp;
## accumulate()怎么连接字符串？原理是？
#### accumulate()连接字符串代码：
```cpp
vector<string>v{"Hello", " ", "world", "!"};
// 输出：Hello world!
string sum1 = accumulate(v.cbegin(), v.cend(), string(""));
// 错误，""是const char*类型，这个类型没有定义+运算符
string sum2 = accumulate(v.cbegin(), v.cend(), "");// 应该像前面一样先把""转为string类型
```
#### accumulate()连接字符串原理
&emsp;&emsp;accumulate()调用的是 第三个参数的+运算符，而string定义了+运算符，所以可以这么操作。
&emsp;&emsp;也就是说，只要 该类型定义了+运算符，就能用accumulate()进行累加操作。



&emsp;
## accumulate()源码
```cpp
//版本1
template <typename InputIterator, typename T>
T accumulate(InputIterator first, InputIterator last, T init) {
	for ( ; first != last; ++first)
		init = init + *first;
	return init;
}

//版本2
template <typename InpurIterator, typename T, typename BinaryOperation>
T accumulate(InputIterator first, InputIterator last, T init, BinaryOperation binary_op) {
	for ( ; first != last; ++first)
		init = binary_op(init, *first);
	return init;
}
```



&emsp;
## equal()函数
#### (1) equal()的函数原型是怎样的？
```cpp
// 版本一：
template<class InputIterator1, class InputIterator2>
bool equal(InputIterator1 _First1, InputIterator1 _Last1, InputIterator2 _First2);
// 版本二：TODO: 讲解一下最后一个参数的意义
template<class InputIterator1, class InputIterator2, class BinaryPredicate>
bool equal(InputIterator1 _First1, InputIterator1 _Last1, InputIterator2 _First2, BinaryPredicate _Comp);
```
#### (2) equal()函数 的原理是？
&emsp;&emsp;和其它泛型算法一样，equal()函数使用的是迭代器来完成操作，所以我们可以使用equal()来比较两个不同类型的容器中的元素，甚至元素的类型也可以不一样（比如一个为string，一个为const char*），只要可以使用 == 来比较两个元素即可：
```cpp
bool fun(int n,int m)
{
    return n * 2 == m;
}
 
int main()
{
    vector<int>v{ 1,2,3,4 };
    list<int>lst{ 1,2,3,4,5};
    cout << equal(v.begin(), v.end(), lst.begin()) << endl;                     // 结果：1
    cout << equal(v.begin(), v.end(), lst.begin(), fun) << endl;                // 结果：0

    vector<const char *>v_char{"Hello", "World"};
    vector<string>v_string{"Hello", "World"};
    cout << equal(v_char.begin(), v_char.end(), v_string.begin()) << endl;      // 结果：1

}
```
#### (3) 使用equal()时需要注意什么？
&emsp;&emsp;和其它只接受一个单一迭代器来表示第二个序列的算法一样，equal()也假定第二个序列至少与第一个序列一样长，因此在调用equal()时可以先对两个序列的大小进行比较，要不然容易发生越界操作。而且如果大小都不一样就没必要调用equal()了。



&emsp;
## fill()算法怎么用？
先接受两个迭代器表示输入区间，然后接受一个值作为第三个参数，fill()将该区间的元素都设为 第三个参数 的值。
```cpp
fill(vec.begin(), vec.end(), 0); // reset each element to 0
fill(vec.begin(), vec.begin() + vec.size()/2, 10);// set a subsequence of the container to 10
```



&emsp;
## string对象 与 char*对象 可以比较吗？
&emsp;&emsp;可以的，String标准库为string对象与char *对象定义了相等（＝＝）操作符



&emsp;
## fill_n()
#### 怎么用？
```cpp
vector<int> vec; 
fill_n(vec.begin(), vec.size(), 0); // 将所有元素都设为0
```
#### 需要注意什么？
&emsp;&emsp;和其它向目的位置写入数据的算法一样，fill_n假定目的位置足够大，能容纳要写入的元素，因此我们在使用fill_n()时需要确保目标容器有足够的空间
&emsp;&emsp;下面是一个错误的用法：
```cpp
vector<int> vec;             // empty vector
fill_n(vec.begin(), 10, 0);  // disaster: attempts to write to ten (nonexistent) elements in vec
```
#### 怎么避免误用？
&emsp;&emsp;配合插入迭代器(insert iterator)使用即可：
```cpp
vector<int> vec; // empty vector
// 正确: 虽然vec是空容器，但是插入迭代器会调用push_back()在vec后面插入元素
fill_n(back_inserter(vec), 10, 0); // appends ten elements to vec
```



&emsp;
## STL算法中查找序列最大值是哪个函数？怎么用？
```cpp
int max= max_element(c.begin(),c.end());// 值得注意的是，max_element()返回的是迭代器，所以需要解引用。
```



&emsp;
## sort()
#### sort()的原理是？
&emsp;&emsp;sort()算法默认调用元素类型的"<"来进行比较，根据比较结果进行排序。
#### 怎么给序列排正（倒）序？
```cpp
vector<int>vec{2,4,1,23,5,76,0,43,24,65};
// sort()函数默认使用 元素类型的 <运算符 来实现排序:
sort(vec.begin(), vec.end();
```
#### 怎么给序列排倒序：
```cpp
// 方法1：传一个方向迭代器进去
sort(vec.rbegin(), vec.rend());
// 方法2：也可以自己定义比较规则，然后作为sort()的第3个参数传进去：
// comparison function to be used to sort by word length
bool isShorter(const string &s1, const string &s2)C++ Primer, Fifth Edition{
    return s1.size() < s2.size();
}
// sort on word length, shortest to longest
sort(words.begin(), words.end(), isShorter);

bool smaller(int a, int b){
    return a > b;
}
sort(vec.begin(), vec.end(), smaller)
```



&emsp;
## copy()
#### (1)函数原型
```cpp
template<class InputIterator, class OutputIterator>  
       OutputIterator copy(  
          InputIterator _First,   
          InputIterator _Last,   
          OutputIterator _DestBeg  
       );
```
#### (2) 注意事项
&emsp;&emsp;和其它接受三个迭代器的算法一样，我们需要保证目的序列的大小不小于输入序列。
#### (3) 内置数组的拷贝
```cpp
int a1[] = {0,1,2,3,4,5,6,7,8,9};
int a2[sizeof(a1) / sizeof(*a1)]; // 保证a1和a2大小一致
auto ret = copy(begin(a1), end(a1), a2) // 成功的话，ret将是a1的尾后迭代器的位置
```
#### (4) 如何利用copy()将 一个vector的元素 复制(插入)到 另一个vector的 末尾？
利用 尾后插入迭代器 即可：
```cpp
vector<int> src = { 0, 1, 2, 3, 4 };
vector<int> dst = { -10, -9 };
auto ret = copy(src.begin(), src.end(), back_inserter(dst));
```



&emsp;
## replace() TODO:
&emsp;&emsp;



&emsp;
## 如何对一个vector进行去重？
&emsp;&emsp;
#### (1)
```cpp
vector<string>vec{the, quick, red, fox, jumps, over, the, slow, red, turtle};
void elimDups(vector<string> &words)
{
    // 先排序，方便找到重复单词
    sort(words.begin(), words.end());
    // unique 重排输入范围，使得每个单词只出现一次
    // unique函数的返回值为 指向不重复区域之后一个位置的迭代器。
    auto end_unique = unique(words.begin(), words.end());
    // 因为泛型算法都不能改变容器大小，一次需要借助vector容器的erase()成员来完成删除操作
    words.erase(end_unique, words.end());
}
elimDups(vec);
```



&emsp;
## 如何对一个vector进行去重？
&emsp;&emsp;
#### (1)
```cpp

```
#### (2) 
&emsp;&emsp;
#### (3) 
&emsp;&emsp;
```cpp

```
#### (4) 
&emsp;&emsp;
```cpp

```
#### (5)
&emsp;&emsp;
```cpp

```
#### (6)
&emsp;&emsp;
```cpp

```